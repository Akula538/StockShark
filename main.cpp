#include <array>
#include <cmath>
#include <iostream>
#include <vector>
using namespace std;
#include <algorithm>
#include <time.h>
#include <string>
#include <set>
#include <stack>
#include <functional>
#include <unordered_map>
#include <unordered_set>

#pragma GCC optimize ("O3,unroll-loops")
#pragma GCC target("avx2,bmi,bmi2,lzcnt,popcnt")


double time_for_move = 5;
double time_for_move_out = 15;

int board_style = 1;
bool printing = false;

int bot_play;

/*
56 57 58 59 60 61 62 63
48 49 50 51 52 53 54 55
40 41 42 43 44 45 46 47
32 33 34 35 36 37 38 39
24 25 26 27 28 29 30 31
16 17 18 19 20 21 22 23
8  9  10 11 12 13 14 15
0  1  2  3  4  5  6  7
*/

//move: UUUPPPTTTTTTFFFFFF

pair<pair<array<unsigned long long, 16>, multiset<unsigned long long>>, pair<array<int, 3>, unsigned long long>> position_start = {{{65280ULL, 66ULL, 36ULL, 129ULL, 8ULL, 16ULL, 71776119061217280ULL, 4755801206503243776ULL, 2594073385365405696ULL, 9295429630892703744ULL, 576460752303423488ULL, 1152921504606846976ULL, 31ULL, 65535ULL, 18446462598732840960ULL, 0ULL}, {}}, {{0, 0, 0}, 0}};


// last: 000..000MMMMMMMTCCCC (white O-O, white O-O-O, black O-O, black O-O-O)

//pair<pair<array<unsigned long long, 16>, multiset<unsigned long long>>, pair<array<int, 3>, unsigned long long>>

const array<unsigned long long, 64> knight_moves = {132096ULL, 329728ULL, 659712ULL, 1319424ULL, 2638848ULL, 5277696ULL, 10489856ULL, 4202496ULL, 33816580ULL, 84410376ULL, 168886289ULL, 337772578ULL, 675545156ULL, 1351090312ULL, 2685403152ULL, 1075839008ULL, 8657044482ULL, 21609056261ULL, 43234889994ULL, 86469779988ULL, 172939559976ULL, 345879119952ULL, 687463207072ULL, 275414786112ULL, 2216203387392ULL, 5531918402816ULL, 11068131838464ULL, 22136263676928ULL, 44272527353856ULL, 88545054707712ULL, 175990581010432ULL, 70506185244672ULL, 567348067172352ULL, 1416171111120896ULL, 2833441750646784ULL, 5666883501293568ULL, 11333767002587136ULL, 22667534005174272ULL, 45053588738670592ULL, 18049583422636032ULL, 145241105196122112ULL, 362539804446949376ULL, 725361088165576704ULL, 1450722176331153408ULL, 2901444352662306816ULL, 5802888705324613632ULL, 11533718717099671552ULL, 4620693356194824192ULL, 288234782788157440ULL, 576469569871282176ULL, 1224997833292120064ULL, 2449995666584240128ULL, 4899991333168480256ULL, 9799982666336960512ULL, 1152939783987658752ULL, 2305878468463689728ULL, 1128098930098176ULL, 2257297371824128ULL, 4796069720358912ULL, 9592139440717824ULL, 19184278881435648ULL, 38368557762871296ULL, 4679521487814656ULL, 9077567998918656ULL};

const array<unsigned long long, 64> king_moves = {770ULL, 1797ULL, 3594ULL, 7188ULL, 14376ULL, 28752ULL, 57504ULL, 49216ULL, 197123ULL, 460039ULL, 920078ULL, 1840156ULL, 3680312ULL, 7360624ULL, 14721248ULL, 12599488ULL, 50463488ULL, 117769984ULL, 235539968ULL, 471079936ULL, 942159872ULL, 1884319744ULL, 3768639488ULL, 3225468928ULL, 12918652928ULL, 30149115904ULL, 60298231808ULL, 120596463616ULL, 241192927232ULL, 482385854464ULL, 964771708928ULL, 825720045568ULL, 3307175149568ULL, 7718173671424ULL, 15436347342848ULL, 30872694685696ULL, 61745389371392ULL, 123490778742784ULL, 246981557485568ULL, 211384331665408ULL, 846636838289408ULL, 1975852459884544ULL, 3951704919769088ULL, 7903409839538176ULL, 15806819679076352ULL, 31613639358152704ULL, 63227278716305408ULL, 54114388906344448ULL, 216739030602088448ULL, 505818229730443264ULL, 1011636459460886528ULL, 2023272918921773056ULL, 4046545837843546112ULL, 8093091675687092224ULL, 16186183351374184448ULL, 13853283560024178688ULL, 144959613005987840ULL, 362258295026614272ULL, 724516590053228544ULL, 1449033180106457088ULL, 2898066360212914176ULL, 5796132720425828352ULL, 11592265440851656704ULL, 4665729213955833856ULL};

const array<unsigned long long, 65> right_ray = {254ULL, 252ULL, 248ULL, 240ULL, 224ULL, 192ULL, 128ULL, 0ULL, 65024ULL, 64512ULL, 63488ULL, 61440ULL, 57344ULL, 49152ULL, 32768ULL, 0ULL, 16646144ULL, 16515072ULL, 16252928ULL, 15728640ULL, 14680064ULL, 12582912ULL, 8388608ULL, 0ULL, 4261412864ULL, 4227858432ULL, 4160749568ULL, 4026531840ULL, 3758096384ULL, 3221225472ULL, 2147483648ULL, 0ULL, 1090921693184ULL, 1082331758592ULL, 1065151889408ULL, 1030792151040ULL, 962072674304ULL, 824633720832ULL, 549755813888ULL, 0ULL, 279275953455104ULL, 277076930199552ULL, 272678883688448ULL, 263882790666240ULL, 246290604621824ULL, 211106232532992ULL, 140737488355328ULL, 0ULL, 71494644084506624ULL, 70931694131085312ULL, 69805794224242688ULL, 67553994410557440ULL, 63050394783186944ULL, 54043195528445952ULL, 36028797018963968ULL, 0ULL, 18302628885633695744ULL, 18158513697557839872ULL, 17870283321406128128ULL, 17293822569102704640ULL, 16140901064495857664ULL, 13835058055282163712ULL, 9223372036854775808ULL, 0ULL, 0ULL};

const array<unsigned long long, 65> left_ray = {0ULL, 1ULL, 3ULL, 7ULL, 15ULL, 31ULL, 63ULL, 127ULL, 0ULL, 256ULL, 768ULL, 1792ULL, 3840ULL, 7936ULL, 16128ULL, 32512ULL, 0ULL, 65536ULL, 196608ULL, 458752ULL, 983040ULL, 2031616ULL, 4128768ULL, 8323072ULL, 0ULL, 16777216ULL, 50331648ULL, 117440512ULL, 251658240ULL, 520093696ULL, 1056964608ULL, 2130706432ULL, 0ULL, 4294967296ULL, 12884901888ULL, 30064771072ULL, 64424509440ULL, 133143986176ULL, 270582939648ULL, 545460846592ULL, 0ULL, 1099511627776ULL, 3298534883328ULL, 7696581394432ULL, 16492674416640ULL, 34084860461056ULL, 69269232549888ULL, 139637976727552ULL, 0ULL, 281474976710656ULL, 844424930131968ULL, 1970324836974592ULL, 4222124650659840ULL, 8725724278030336ULL, 17732923532771328ULL, 35747322042253312ULL, 0ULL, 72057594037927936ULL, 216172782113783808ULL, 504403158265495552ULL, 1080863910568919040ULL, 2233785415175766016ULL, 4539628424389459968ULL, 9151314442816847872ULL, 0ULL};

const array<unsigned long long, 65> up_ray = {72340172838076672ULL, 144680345676153344ULL, 289360691352306688ULL, 578721382704613376ULL, 1157442765409226752ULL, 2314885530818453504ULL, 4629771061636907008ULL, 9259542123273814016ULL, 72340172838076416ULL, 144680345676152832ULL, 289360691352305664ULL, 578721382704611328ULL, 1157442765409222656ULL, 2314885530818445312ULL, 4629771061636890624ULL, 9259542123273781248ULL, 72340172838010880ULL, 144680345676021760ULL, 289360691352043520ULL, 578721382704087040ULL, 1157442765408174080ULL, 2314885530816348160ULL, 4629771061632696320ULL, 9259542123265392640ULL, 72340172821233664ULL, 144680345642467328ULL, 289360691284934656ULL, 578721382569869312ULL, 1157442765139738624ULL, 2314885530279477248ULL, 4629771060558954496ULL, 9259542121117908992ULL, 72340168526266368ULL, 144680337052532736ULL, 289360674105065472ULL, 578721348210130944ULL, 1157442696420261888ULL, 2314885392840523776ULL, 4629770785681047552ULL, 9259541571362095104ULL, 72339069014638592ULL, 144678138029277184ULL, 289356276058554368ULL, 578712552117108736ULL, 1157425104234217472ULL, 2314850208468434944ULL, 4629700416936869888ULL, 9259400833873739776ULL, 72057594037927936ULL, 144115188075855872ULL, 288230376151711744ULL, 576460752303423488ULL, 1152921504606846976ULL, 2305843009213693952ULL, 4611686018427387904ULL, 9223372036854775808ULL, 0ULL, 0ULL, 0ULL, 0ULL, 0ULL, 0ULL, 0ULL, 0ULL, 0ULL};

const array<unsigned long long, 65> down_ray = {0ULL, 0ULL, 0ULL, 0ULL, 0ULL, 0ULL, 0ULL, 0ULL, 1ULL, 2ULL, 4ULL, 8ULL, 16ULL, 32ULL, 64ULL, 128ULL, 257ULL, 514ULL, 1028ULL, 2056ULL, 4112ULL, 8224ULL, 16448ULL, 32896ULL, 65793ULL, 131586ULL, 263172ULL, 526344ULL, 1052688ULL, 2105376ULL, 4210752ULL, 8421504ULL, 16843009ULL, 33686018ULL, 67372036ULL, 134744072ULL, 269488144ULL, 538976288ULL, 1077952576ULL, 2155905152ULL, 4311810305ULL, 8623620610ULL, 17247241220ULL, 34494482440ULL, 68988964880ULL, 137977929760ULL, 275955859520ULL, 551911719040ULL, 1103823438081ULL, 2207646876162ULL, 4415293752324ULL, 8830587504648ULL, 17661175009296ULL, 35322350018592ULL, 70644700037184ULL, 141289400074368ULL, 282578800148737ULL, 565157600297474ULL, 1130315200594948ULL, 2260630401189896ULL, 4521260802379792ULL, 9042521604759584ULL, 18085043209519168ULL, 36170086419038336ULL, 0ULL};

const array<unsigned long long, 65> right_up_ray = {9241421688590303744ULL, 36099303471055872ULL, 141012904183808ULL, 550831656960ULL, 2151686144ULL, 8404992ULL, 32768ULL, 0ULL, 4620710844295151616ULL, 9241421688590303232ULL, 36099303471054848ULL, 141012904181760ULL, 550831652864ULL, 2151677952ULL, 8388608ULL, 0ULL, 2310355422147510272ULL, 4620710844295020544ULL, 9241421688590041088ULL, 36099303470530560ULL, 141012903133184ULL, 550829555712ULL, 2147483648ULL, 0ULL, 1155177711056977920ULL, 2310355422113955840ULL, 4620710844227911680ULL, 9241421688455823360ULL, 36099303202095104ULL, 141012366262272ULL, 549755813888ULL, 0ULL, 577588851233521664ULL, 1155177702467043328ULL, 2310355404934086656ULL, 4620710809868173312ULL, 9241421619736346624ULL, 36099165763141632ULL, 140737488355328ULL, 0ULL, 288793326105133056ULL, 577586652210266112ULL, 1155173304420532224ULL, 2310346608841064448ULL, 4620693217682128896ULL, 9241386435364257792ULL, 36028797018963968ULL, 0ULL, 144115188075855872ULL, 288230376151711744ULL, 576460752303423488ULL, 1152921504606846976ULL, 2305843009213693952ULL, 4611686018427387904ULL, 9223372036854775808ULL, 0ULL, 0ULL, 0ULL, 0ULL, 0ULL, 0ULL, 0ULL, 0ULL, 0ULL, 0ULL};

const array<unsigned long long, 65> right_down_ray = {0ULL, 0ULL, 0ULL, 0ULL, 0ULL, 0ULL, 0ULL, 0ULL, 2ULL, 4ULL, 8ULL, 16ULL, 32ULL, 64ULL, 128ULL, 0ULL, 516ULL, 1032ULL, 2064ULL, 4128ULL, 8256ULL, 16512ULL, 32768ULL, 0ULL, 132104ULL, 264208ULL, 528416ULL, 1056832ULL, 2113664ULL, 4227072ULL, 8388608ULL, 0ULL, 33818640ULL, 67637280ULL, 135274560ULL, 270549120ULL, 541097984ULL, 1082130432ULL, 2147483648ULL, 0ULL, 8657571872ULL, 17315143744ULL, 34630287488ULL, 69260574720ULL, 138521083904ULL, 277025390592ULL, 549755813888ULL, 0ULL, 2216338399296ULL, 4432676798592ULL, 8865353596928ULL, 17730707128320ULL, 35461397479424ULL, 70918499991552ULL, 140737488355328ULL, 0ULL, 567382630219904ULL, 1134765260439552ULL, 2269530520813568ULL, 4539061024849920ULL, 9078117754732544ULL, 18155135997837312ULL, 36028797018963968ULL, 0ULL, 0ULL};

const array<unsigned long long, 65> left_up_ray = {0ULL, 256ULL, 66048ULL, 16909312ULL, 4328785920ULL, 1108169199616ULL, 283691315109888ULL, 72624976668147712ULL, 0ULL, 65536ULL, 16908288ULL, 4328783872ULL, 1108169195520ULL, 283691315101696ULL, 72624976668131328ULL, 145249953336262656ULL, 0ULL, 16777216ULL, 4328521728ULL, 1108168671232ULL, 283691314053120ULL, 72624976666034176ULL, 145249953332068352ULL, 290499906664136704ULL, 0ULL, 4294967296ULL, 1108101562368ULL, 283691179835392ULL, 72624976397598720ULL, 145249952795197440ULL, 290499905590394880ULL, 580999811180789760ULL, 0ULL, 1099511627776ULL, 283673999966208ULL, 72624942037860352ULL, 145249884075720704ULL, 290499768151441408ULL, 580999536302882816ULL, 1161999072605765632ULL, 0ULL, 281474976710656ULL, 72620543991349248ULL, 145241087982698496ULL, 290482175965396992ULL, 580964351930793984ULL, 1161928703861587968ULL, 2323857407723175936ULL, 0ULL, 72057594037927936ULL, 144115188075855872ULL, 288230376151711744ULL, 576460752303423488ULL, 1152921504606846976ULL, 2305843009213693952ULL, 4611686018427387904ULL, 0ULL, 0ULL, 0ULL, 0ULL, 0ULL, 0ULL, 0ULL, 0ULL, 0ULL};

const array<unsigned long long, 65> left_down_ray = {0ULL, 0ULL, 0ULL, 0ULL, 0ULL, 0ULL, 0ULL, 0ULL, 0ULL, 1ULL, 2ULL, 4ULL, 8ULL, 16ULL, 32ULL, 64ULL, 0ULL, 256ULL, 513ULL, 1026ULL, 2052ULL, 4104ULL, 8208ULL, 16416ULL, 0ULL, 65536ULL, 131328ULL, 262657ULL, 525314ULL, 1050628ULL, 2101256ULL, 4202512ULL, 0ULL, 16777216ULL, 33619968ULL, 67240192ULL, 134480385ULL, 268960770ULL, 537921540ULL, 1075843080ULL, 0ULL, 4294967296ULL, 8606711808ULL, 17213489152ULL, 34426978560ULL, 68853957121ULL, 137707914242ULL, 275415828484ULL, 0ULL, 1099511627776ULL, 2203318222848ULL, 4406653222912ULL, 8813306511360ULL, 17626613022976ULL, 35253226045953ULL, 70506452091906ULL, 0ULL, 281474976710656ULL, 564049465049088ULL, 1128103225065472ULL, 2256206466908160ULL, 4512412933881856ULL, 9024825867763968ULL, 18049651735527937ULL, 0ULL};

const array<unsigned long long, 65> one_mask = {1ULL, 2ULL, 4ULL, 8ULL, 16ULL, 32ULL, 64ULL, 128ULL, 256ULL, 512ULL, 1024ULL, 2048ULL, 4096ULL, 8192ULL, 16384ULL, 32768ULL, 65536ULL, 131072ULL, 262144ULL, 524288ULL, 1048576ULL, 2097152ULL, 4194304ULL, 8388608ULL, 16777216ULL, 33554432ULL, 67108864ULL, 134217728ULL, 268435456ULL, 536870912ULL, 1073741824ULL, 2147483648ULL, 4294967296ULL, 8589934592ULL, 17179869184ULL, 34359738368ULL, 68719476736ULL, 137438953472ULL, 274877906944ULL, 549755813888ULL, 1099511627776ULL, 2199023255552ULL, 4398046511104ULL, 8796093022208ULL, 17592186044416ULL, 35184372088832ULL, 70368744177664ULL, 140737488355328ULL, 281474976710656ULL, 562949953421312ULL, 1125899906842624ULL, 2251799813685248ULL, 4503599627370496ULL, 9007199254740992ULL, 18014398509481984ULL, 36028797018963968ULL, 72057594037927936ULL, 144115188075855872ULL, 288230376151711744ULL, 576460752303423488ULL, 1152921504606846976ULL, 2305843009213693952ULL, 4611686018427387904ULL, 9223372036854775808ULL, 0ULL};

const array<unsigned long long, 65> passing_mask_white = {217020518514230016ULL, 506381209866536704ULL, 1012762419733073408ULL, 2025524839466146816ULL, 4051049678932293632ULL, 8102099357864587264ULL, 16204198715729174528ULL, 13889313184910721024ULL, 217020518514229248ULL, 506381209866534912ULL, 1012762419733069824ULL, 2025524839466139648ULL, 4051049678932279296ULL, 8102099357864558592ULL, 16204198715729117184ULL, 13889313184910671872ULL, 217020518514032640ULL, 506381209866076160ULL, 1012762419732152320ULL, 2025524839464304640ULL, 4051049678928609280ULL, 8102099357857218560ULL, 16204198715714437120ULL, 13889313184898088960ULL, 217020518463700992ULL, 506381209748635648ULL, 1012762419497271296ULL, 2025524838994542592ULL, 4051049677989085184ULL, 8102099355978170368ULL, 16204198711956340736ULL, 13889313181676863488ULL, 217020505578799104ULL, 506381179683864576ULL, 1012762359367729152ULL, 2025524718735458304ULL, 4051049437470916608ULL, 8102098874941833216ULL, 16204197749883666432ULL, 13889312357043142656ULL, 217017207043915776ULL, 506373483102470144ULL, 1012746966204940288ULL, 2025493932409880576ULL, 4050987864819761152ULL, 8101975729639522304ULL, 16203951459279044608ULL, 13889101250810609664ULL, 216172782113783808ULL, 504403158265495552ULL, 1008806316530991104ULL, 2017612633061982208ULL, 4035225266123964416ULL, 8070450532247928832ULL, 16140901064495857664ULL, 13835058055282163712ULL, 0ULL, 0ULL, 0ULL, 0ULL, 0ULL, 0ULL, 0ULL, 0ULL, 0ULL};

const array<unsigned long long, 65> passing_mask_black = {0ULL, 0ULL, 0ULL, 0ULL, 0ULL, 0ULL, 0ULL, 0ULL, 3ULL, 7ULL, 14ULL, 28ULL, 56ULL, 112ULL, 224ULL, 192ULL, 771ULL, 1799ULL, 3598ULL, 7196ULL, 14392ULL, 28784ULL, 57568ULL, 49344ULL, 197379ULL, 460551ULL, 921102ULL, 1842204ULL, 3684408ULL, 7368816ULL, 14737632ULL, 12632256ULL, 50529027ULL, 117901063ULL, 235802126ULL, 471604252ULL, 943208504ULL, 1886417008ULL, 3772834016ULL, 3233857728ULL, 12935430915ULL, 30182672135ULL, 60365344270ULL, 120730688540ULL, 241461377080ULL, 482922754160ULL, 965845508320ULL, 827867578560ULL, 3311470314243ULL, 7726764066567ULL, 15453528133134ULL, 30907056266268ULL, 61814112532536ULL, 123628225065072ULL, 247256450130144ULL, 211934100111552ULL, 847736400446211ULL, 1978051601041159ULL, 3956103202082318ULL, 7912206404164636ULL, 15824412808329272ULL, 31648825616658544ULL, 63297651233317088ULL, 54255129628557504ULL, 0ULL};

const array<unsigned long long, 65> white_king_zone = {197378ULL, 460549ULL, 921098ULL, 1842196ULL, 3684392ULL, 7368784ULL, 14737568ULL, 12632128ULL, 50528771ULL, 117900551ULL, 235801102ULL, 471602204ULL, 943204408ULL, 1886408816ULL, 3772817632ULL, 3233824960ULL, 12935365376ULL, 30182541056ULL, 60365082112ULL, 120730164224ULL, 241460328448ULL, 482920656896ULL, 965841313792ULL, 827859189760ULL, 3311453536256ULL, 7726730510336ULL, 15453461020672ULL, 30906922041344ULL, 61813844082688ULL, 123627688165376ULL, 247255376330752ULL, 211931952578560ULL, 847732105281536ULL, 1978043010646016ULL, 3956086021292032ULL, 7912172042584064ULL, 15824344085168128ULL, 31648688170336256ULL, 63297376340672512ULL, 54254579860111360ULL, 217019418952073216ULL, 506379010725380096ULL, 1012758021450760192ULL, 2025516042901520384ULL, 4051032085803040768ULL, 8102064171606081536ULL, 16204128343212163072ULL, 13889172444188508160ULL, 216739030602088448ULL, 505818229730443264ULL, 1011636459460886528ULL, 2023272918921773056ULL, 4046545837843546112ULL, 8093091675687092224ULL, 16186183351374184448ULL, 13853283560024178688ULL, 144959613005987840ULL, 362258295026614272ULL, 724516590053228544ULL, 1449033180106457088ULL, 2898066360212914176ULL, 5796132720425828352ULL, 11592265440851656704ULL, 4665729213955833856ULL, 0ULL};

const array<unsigned long long, 65> black_king_zone = {770ULL, 1797ULL, 3594ULL, 7188ULL, 14376ULL, 28752ULL, 57504ULL, 49216ULL, 197123ULL, 460039ULL, 920078ULL, 1840156ULL, 3680312ULL, 7360624ULL, 14721248ULL, 12599488ULL, 50463491ULL, 117769991ULL, 235539982ULL, 471079964ULL, 942159928ULL, 1884319856ULL, 3768639712ULL, 3225469120ULL, 12918653696ULL, 30149117696ULL, 60298235392ULL, 120596470784ULL, 241192941568ULL, 482385883136ULL, 964771766272ULL, 825720094720ULL, 3307175346176ULL, 7718174130176ULL, 15436348260352ULL, 30872696520704ULL, 61745393041408ULL, 123490786082816ULL, 246981572165632ULL, 211384344248320ULL, 846636888621056ULL, 1975852577325056ULL, 3951705154650112ULL, 7903410309300224ULL, 15806820618600448ULL, 31613641237200896ULL, 63227282474401792ULL, 54114392127569920ULL, 216739043486990336ULL, 505818259795214336ULL, 1011636519590428672ULL, 2023273039180857344ULL, 4046546078361714688ULL, 8093092156723429376ULL, 16186184313446858752ULL, 13853284384657899520ULL, 144962911540871168ULL, 362265991608008704ULL, 724531983216017408ULL, 1449063966432034816ULL, 2898127932864069632ULL, 5796255865728139264ULL, 11592511731456278528ULL, 4665940320188366848ULL, 0ULL};


const unsigned long long RANK_1 = 255ULL;
const unsigned long long RANK_4 = 4278190080ULL;
const unsigned long long RANK_5 = 1095216660480ULL;
const unsigned long long RANK_8 = 18374686479671623680ULL;

const unsigned long long RANK_A = 72340172838076673ULL;
const unsigned long long RANK_H = 9259542123273814144ULL;

const unsigned long long WHITE_SQUARES = 12297829382473034410ULL;
const unsigned long long BLACK_SQUARES = 6148914691236517205ULL;

array<int, 6> material_costs = {100, 320, 330, 500, 900, 20000};


// version 7
array<int, 64> white_Pawn_opening =
{-17, -11, -18, -18, -19, -17, -9, -19,
72, 69, 69, 70, 82, 76, 72, 75,
78, 84, 85, 87, 83, 79, 82, 79,
89, 84, 91, 99, 91, 79, 90, 81,
99, 97, 96, 100, 103, 78, 89, 103,
94, 98, 104, 113, 111, 105, 105, 112,
111, 99, 112, 115, 114, 105, 103, 105,
782, 781, 794, 782, 782, 785, 785, 790};
array<int, 64> white_Knight_opening =
{271, 274, 284, 287, 291, 274, 280, 273,
281, 279, 294, 298, 303, 301, 274, 276,
279, 293, 296, 311, 304, 303, 303, 274,
294, 304, 305, 312, 299, 310, 302, 292,
297, 309, 305, 311, 303, 308, 308, 303,
274, 300, 301, 312, 310, 301, 298, 285,
277, 272, 300, 296, 299, 301, 273, 271,
273, 270, 280, 291, 293, 276, 276, 273};
array<int, 64> white_Bishop_opening =
{300, 299, 292, 313, 307, 290, 306, 312,
292, 316, 300, 300, 304, 303, 313, 296,
299, 302, 324, 309, 306, 319, 305, 303,
311, 315, 320, 320, 323, 317, 308, 305,
314, 300, 327, 316, 328, 328, 308, 309,
297, 300, 322, 316, 311, 317, 301, 299,
292, 311, 300, 302, 304, 304, 312, 301,
307, 301, 289, 316, 321, 296, 298, 312};
array<int, 64> white_Rook_opening =
{497, 499, 498, 512, 524, 506, 488, 497,
500, 499, 502, 504, 501, 496, 506, 496,
509, 497, 496, 496, 498, 500, 501, 510,
507, 504, 499, 514, 500, 490, 507, 502,
506, 506, 499, 497, 504, 488, 495, 505,
503, 490, 496, 494, 498, 502, 497, 500,
515, 528, 528, 533, 526, 527, 529, 516,
516, 516, 515, 520, 511, 518, 518, 525};
array<int, 64> white_Queen_opening =
{880, 893, 896, 902, 895, 898, 892, 887,
899, 900, 900, 898, 902, 902, 897, 908,
902, 899, 900, 897, 903, 898, 898, 905,
902, 897, 901, 894, 897, 900, 904, 900,
899, 902, 903, 896, 903, 904, 898, 899,
895, 900, 899, 901, 897, 896, 893, 901,
916, 912, 915, 916, 905, 916, 914, 914,
926, 929, 936, 925, 938, 927, 929, 929};
array<int, 64> white_King_opening =
{20008, 20004, 20018, 20004, 19999, 19995, 20026, 20005,
20011, 20003, 20001, 20001, 19990, 20003, 20004, 20005,
19996, 20000, 19994, 20000, 19994, 19992, 20001, 20001,
19989, 19997, 19998, 20000, 19998, 20000, 20004, 19999,
20000, 19998, 20001, 19995, 19997, 20000, 20002, 19998,
20002, 19993, 20006, 20000, 19996, 20000, 19991, 20000,
20004, 20009, 20008, 20006, 19998, 20004, 20004, 19996,
20003, 20001, 19991, 19991, 19999, 20001, 19995, 20005};
array<int, 64> black_Pawn_opening =
{-792, -782, -786, -787, -782, -785, -787, -777,
-99, -110, -117, -119, -116, -113, -103, -105,
-110, -103, -106, -110, -104, -107, -93, -98,
-95, -89, -91, -101, -105, -77, -89, -90,
-81, -90, -89, -88, -89, -77, -90, -83,
-89, -85, -84, -87, -95, -73, -81, -82,
-76, -72, -80, -76, -72, -73, -70, -73,
15, 18, 14, 12, 15, 15, 15, 14};
array<int, 64> black_Knight_opening =
{-274, -275, -281, -294, -291, -282, -278, -274,
-281, -272, -293, -295, -293, -300, -276, -278,
-279, -302, -296, -310, -309, -305, -293, -275,
-297, -302, -308, -296, -304, -310, -304, -305,
-305, -304, -305, -312, -309, -313, -307, -307,
-271, -306, -303, -312, -311, -304, -289, -289,
-271, -267, -303, -293, -293, -308, -280, -273,
-271, -281, -277, -290, -288, -281, -283, -272};
array<int, 64> black_Bishop_opening =
{-307, -291, -305, -311, -318, -296, -306, -308,
-295, -308, -292, -304, -300, -295, -321, -300,
-306, -299, -313, -307, -314, -327, -304, -298,
-308, -302, -323, -320, -320, -324, -311, -315,
-316, -303, -312, -317, -322, -314, -316, -312,
-298, -302, -320, -309, -311, -319, -293, -297,
-295, -307, -301, -299, -294, -309, -327, -304,
-308, -298, -286, -317, -309, -282, -297, -306};
array<int, 64> black_Rook_opening =
{-512, -521, -521, -516, -519, -516, -523, -517,
-523, -529, -532, -531, -524, -526, -530, -522,
-511, -496, -496, -498, -504, -497, -493, -506,
-502, -499, -502, -501, -499, -500, -503, -511,
-508, -495, -499, -510, -510, -500, -508, -511,
-509, -501, -500, -496, -504, -500, -503, -506,
-494, -506, -507, -495, -486, -501, -505, -500,
-495, -499, -504, -515, -511, -513, -493, -499};
array<int, 64> black_Queen_opening =
{-928, -930, -919, -928, -930, -926, -937, -928,
-915, -906, -909, -920, -912, -919, -918, -916,
-904, -901, -901, -906, -901, -898, -899, -891,
-896, -899, -904, -896, -906, -901, -898, -897,
-904, -895, -897, -897, -900, -907, -893, -894,
-903, -896, -901, -894, -896, -896, -899, -904,
-899, -893, -903, -900, -902, -901, -891, -899,
-875, -895, -888, -901, -898, -891, -890, -878};
array<int, 64> black_King_opening =
{-20007, -19994, -19998, -19995, -20002, -20001, -20006, -19997,
-19993, -20003, -20004, -20000, -20000, -20006, -19996, -20001,
-20012, -19996, -19997, -20000, -20000, -19992, -19999, -19999,
-20001, -20000, -19999, -20008, -20007, -20000, -19994, -20001,
-20007, -19991, -20000, -19999, -19995, -19999, -20004, -20006,
-19996, -19986, -19995, -19999, -20004, -20008, -20004, -20004,
-20005, -19999, -20001, -20001, -20001, -20007, -20004, -19998,
-20009, -19999, -20026, -19995, -20005, -19996, -20019, -20008};
array<int, 64> white_Pawn_endgame =
{0, 1, 9, 3, 0, 1, 2, 8,
100, 105, 107, 93, 99, 89, 96, 98,
97, 99, 103, 102, 108, 99, 107, 100,
101, 94, 100, 108, 105, 109, 99, 105,
112, 109, 111, 111, 112, 109, 111, 110,
111, 111, 116, 114, 107, 111, 122, 113,
119, 119, 122, 111, 124, 120, 130, 119,
898, 895, 896, 895, 901, 902, 896, 894};
array<int, 64> white_Knight_endgame =
{279, 273, 274, 286, 280, 287, 283, 282,
274, 296, 297, 293, 291, 296, 289, 293,
278, 292, 293, 295, 306, 296, 286, 282,
295, 294, 293, 299, 314, 299, 287, 286,
280, 297, 293, 310, 306, 304, 290, 282,
282, 288, 297, 302, 300, 299, 290, 288,
276, 289, 390, 296, 294, 303, 287, 281,
282, 288, 277, 283, 292, 280, 285, 281};
array<int, 64> white_Bishop_endgame =
{300, 289, 292, 287, 294, 295, 297, 298,
291, 310, 295, 306, 306, 307, 309, 295,
302, 295, 314, 313, 309, 317, 302, 301,
284, 299, 312, 315, 319, 307, 298, 303,
292, 300, 302, 320, 317, 309, 301, 294,
290, 296, 308, 311, 312, 306, 295, 294,
288, 304, 305, 297, 301, 297, 307, 294,
306, 298, 295, 294, 295, 295, 293, 291};
array<int, 64> white_Rook_endgame =
{503, 505, 505, 496, 497, 507, 495, 500,
501, 499, 494, 489, 492, 496, 495, 499,
499, 506, 499, 502, 498, 501, 500, 499,
498, 507, 495, 494, 496, 500, 502, 499,
501, 491, 499, 495, 499, 507, 495, 505,
501, 496, 494, 504, 505, 494, 493, 503,
514, 522, 511, 509, 520, 516, 507, 517,
499, 507, 503, 504, 505, 508, 493, 505};
array<int, 64> white_Queen_endgame =
{893, 896, 908, 902, 901, 903, 900, 896,
892, 897, 894, 892, 899, 896, 903, 904,
901, 895, 896, 901, 895, 901, 893, 899,
897, 896, 905, 900, 905, 893, 896, 902,
893, 904, 904, 905, 898, 896, 903, 900,
902, 897, 903, 893, 896, 893, 903, 910,
902, 896, 898, 897, 897, 904, 897, 899,
899, 894, 904, 910, 897, 901, 890, 898};
array<int, 64> white_King_endgame =
{20000, 19997, 20005, 19999, 20002, 19999, 19996, 20007,
20000, 20006, 20003, 20016, 20012, 20005, 19999, 20005,
20015, 20008, 20011, 20019, 20013, 20000, 20008, 20006,
20006, 20012, 20019, 20019, 20021, 20020, 20008, 20006,
19999, 20018, 20016, 20029, 20020, 20017, 20013, 20012,
20015, 20026, 20021, 20025, 20021, 20030, 20020, 20013,
20016, 20032, 20028, 20017, 20028, 20025, 20021, 20029,
20001, 19994, 19996, 20000, 20001, 20002, 20000, 20007};
array<int, 64> black_Pawn_endgame =
{-894, -894, -899, -900, -896, -895, -899, -897,
-120, -119, -118, -125, -122, -113, -116, -122,
-122, -115, -115, -109, -115, -120, -113, -112,
-112, -107, -115, -108, -109, -106, -104, -106,
-108, -106, -97, -96, -105, -106, -98, -108,
-101, -106, -107, -97, -101, -101, -96, -101,
-106, -99, -104, -99, -101, -96, -95, -101,
2, 3, 3, 0, -2, -5, 2, -12};
array<int, 64> black_Knight_endgame =
{-277, -284, -280, -289, -278, -285, -280, -280,
-283, -287, -288, -299, -295, -285, -287, -284,
-283, -288, -304, -299, -298, -298, -285, -281,
-285, -289, -300, -299, -302, -295, -286, -284,
-293, -283, -290, -311, -306, -304, -285, -282,
-288, -292, -297, -294, -300, -297, -286, -287,
-286, -287, -388, -289, -291, -284, -292, -284,
-279, -294, -285, -291, -285, -284, -280, -281};
array<int, 64> black_Bishop_endgame =
{-303, -296, -296, -296, -286, -297, -296, -298,
-292, -303, -307, -299, -298, -304, -310, -293,
-288, -293, -315, -312, -315, -312, -306, -303,
-295, -299, -311, -324, -316, -309, -302, -291,
-297, -290, -309, -302, -314, -304, -296, -292,
-297, -297, -313, -305, -313, -320, -294, -300,
-293, -306, -291, -299, -304, -302, -310, -307,
-295, -293, -293, -288, -290, -293, -296, -299};
array<int, 64> black_Rook_endgame =
{-506, -502, -502, -503, -507, -501, -507, -506,
-517, -511, -510, -520, -507, -515, -511, -514,
-491, -501, -497, -502, -500, -497, -500, -499,
-500, -496, -496, -496, -497, -491, -496, -492,
-496, -497, -499, -498, -494, -499, -506, -505,
-487, -507, -496, -497, -502, -505, -503, -497,
-496, -504, -494, -505, -506, -505, -497, -501,
-511, -502, -501, -501, -505, -502, -503, -503};
array<int, 64> black_Queen_endgame =
{-895, -906, -889, -893, -898, -896, -905, -897,
-896, -900, -900, -894, -904, -894, -897, -900,
-896, -896, -898, -906, -900, -905, -897, -901,
-894, -898, -902, -900, -896, -904, -900, -904,
-897, -894, -892, -899, -906, -898, -892, -900,
-901, -898, -906, -899, -902, -901, -895, -897,
-903, -899, -894, -899, -897, -895, -898, -904,
-900, -903, -903, -904, -906, -905, -898, -905};
array<int, 64> black_King_endgame =
{-20000, -19993, -19993, -19996, -20002, -19989, -19995, -20000,
-20023, -20021, -20021, -20026, -20018, -20025, -20023, -20029,
-20012, -20030, -20024, -20029, -20015, -20022, -20018, -20016,
-20007, -20009, -20025, -20017, -20012, -20021, -20012, -20018,
-20012, -20010, -20014, -20025, -20026, -20007, -20011, -20013,
-20010, -20005, -20011, -20017, -20019, -20018, -20013, -20000,
-20002, -19996, -20002, -20017, -20014, -19998, -20004, -20001,
-20001, -19999, -20005, -20005, -20008, -20000, -20003, -19997};


array<array<int, 64>, 12> piece_square_tables_opening = {white_Pawn_opening, white_Knight_opening, white_Bishop_opening, white_Rook_opening, white_Queen_opening, white_King_opening, black_Pawn_opening, black_Knight_opening, black_Bishop_opening, black_Rook_opening, black_Queen_opening, black_King_opening};

array<array<int, 64>, 12> piece_square_tables_end_game = {white_Pawn_endgame, white_Knight_endgame, white_Bishop_endgame, white_Rook_endgame, white_Queen_endgame, white_King_endgame, black_Pawn_endgame, black_Knight_endgame, black_Bishop_endgame, black_Rook_endgame, black_Queen_endgame, black_King_endgame};

array<array<array<int, 64>, 12>, 2> piece_square_tables = {piece_square_tables_opening, piece_square_tables_end_game};


stack<pair<pair<array<unsigned long long, 16>, multiset<unsigned long long>>, pair<array<int, 3>, unsigned long long>>> history;

array<array<array<int, 64>, 64>, 2> history_evr;
array<array<int, 64>, 64> counterMove;

const int INF = 1000000;


clock_t start;
int DEPTH, depth_dictated;
int best_move = 0;

array<array<unsigned int, 64>, 14> zobrist_32 = {{{1933848796, 2758896729, 3267706088, 4251953830, 3092665001, 650449631, 565245684, 2999696430, 3336583848, 2363312801, 3898633384, 3989094108, 961111082, 1709039804, 2968653690, 4100675117, 3580303925, 369959857, 3329680452, 1816170146, 2037231715, 1386097874, 1777932333, 1034249979, 1055125495, 3969974463, 3821413362, 467138745, 3245911143, 3551290048, 683842871, 141327489, 4031843221, 1666285673, 4069174358, 3326744274, 1964084828, 702029148, 3042019334, 1499913388, 2667728913, 1576517918, 841663170, 3758488737, 1622388508, 2928311348, 2874247378, 1983813283, 1830698987, 2262687489, 1179448766, 3797370324, 4064172909, 2775252440, 1766234286, 2356385873, 675635149, 1332722614, 843819617, 2910561200, 256466398, 1642837046, 53599492, 2376705225}, {951988371, 3351427804, 2958982220, 3547460620, 3217768821, 2377823192, 14672639, 464751365, 1829633467, 666173429, 3560365250, 2630927734, 1219002135, 3808310179, 895710927, 3942405395, 644337655, 3549720767, 2091981779, 2859297873, 3971642664, 2289721876, 2098535265, 3006672886, 3009181480, 1155275522, 3465978050, 1062314123, 961221126, 3767598059, 241286212, 1021842641, 1554058039, 3086415044, 1953225469, 3025825774, 2882149015, 81269143, 2957668306, 1958630435, 1507010003, 2895985899, 1748906929, 2757359801, 2106391977, 3134807610, 3516205826, 1047610138, 1314397560, 3595184937, 184158485, 4070620430, 3202863519, 2029058575, 2649964792, 1169529481, 847600098, 3992274607, 1767292434, 3010049514, 3082535651, 2348812307, 1456141431, 49126613}, {980272071, 2445069130, 1126467119, 2266965062, 2669529253, 3455389644, 2456506589, 1846140152, 712383293, 710316541, 3966688462, 3034769901, 3354096759, 3168472893, 2630588386, 457636890, 1368170114, 2828766794, 3250824692, 1460455092, 955958051, 2020718803, 906499512, 4110573154, 777537352, 3521833023, 2551061268, 3245489172, 3989333416, 329299846, 3441221022, 1452040298, 271713184, 4267740924, 1377380565, 3983151706, 4194918937, 233115493, 3516856116, 3117419280, 3791146075, 783747785, 1709714337, 256249298, 4166599280, 565648325, 3128393716, 4243504758, 3782748634, 2759993260, 3615170057, 2186479014, 2658036184, 4182948544, 1228459036, 2926006574, 4150654852, 3704956522, 383880988, 4259335632, 2715423941, 1788638701, 3879958815, 999207954}, {3621204610, 3421434047, 2624881989, 2532270623, 2988890503, 391585728, 1027405215, 80064538, 1375092416, 3725059913, 1841767019, 2042493308, 1143833393, 1955498754, 1209413984, 2237657702, 1051361423, 2529828240, 3869071707, 2094195875, 1320002573, 1861201961, 2259736812, 4200187571, 3027688099, 2434764222, 37146937, 3485698262, 924841509, 3429190299, 4144852445, 3619826420, 2503574582, 3885109711, 82510825, 496447067, 1767976611, 4058660231, 3626853596, 2236170529, 3004443715, 2389706395, 45253931, 1080554849, 3949046674, 1278689109, 4195879096, 1750183268, 4214870473, 1884874864, 2320036767, 3492616534, 1758231913, 3715875209, 1076881180, 2415293730, 3767647462, 1858591054, 1370098115, 2441505523, 3749851771, 4254672917, 4264775645, 1236284039}, {2617237789, 1526828651, 2642975080, 3567484484, 2634541141, 336818411, 992428961, 1389364208, 4176755057, 2082924832, 1853350778, 3737183933, 140883214, 801264048, 1365457193, 2944892693, 972954265, 3704538429, 3225528343, 930945990, 3527679516, 3041431869, 4082573696, 3976621931, 166904560, 1783154515, 180452283, 84675621, 4216622054, 1829900764, 1466423064, 749978500, 31238114, 4202437587, 3063347538, 955051697, 2790386667, 4079491513, 3356039718, 111079840, 2707624360, 3609474475, 564635440, 3841366928, 3761301883, 2070882883, 1004677861, 4072042067, 1581771753, 2858309734, 3382142760, 4071356376, 3721712589, 539419247, 2781509935, 263923501, 1420761275, 2894158932, 1529955203, 3508220143, 160141879, 1718234873, 3548987057, 3800564675}, {3711628813, 3316824904, 999764687, 3657997133, 1165474095, 1803606090, 2389502390, 205125436, 4237028547, 127156019, 1166682330, 3409160116, 3760215955, 3763227551, 2808909057, 1594165120, 500574146, 3827743324, 2516613149, 2202924409, 865711932, 434610802, 4274590396, 1032827358, 2329431378, 1561964604, 3270156190,515613696, 1474943227, 2279046058, 2744356021, 1717140823, 3854590772, 2436891562, 811590510, 3499925564, 81232846, 3373764367, 3333296576, 1982166930, 2574446076, 4009412988, 2885556546, 2609808306, 591513287, 4123033094, 1108932362, 3384408091, 2910254548, 3320802066, 3291508248, 1663621065, 2228673740, 2597764006, 2756512908, 3831806748, 3079575686, 3755089916, 3488516523, 2402413967, 475436182, 440250151, 2864140125, 700321438}, {3980041133, 2666260257, 1146870210, 3359761285, 2546715794, 1861379535, 2914908321, 3592744458, 3647772653, 904763819, 4236326497, 2751037444, 3324216558, 2937627576, 4281122524, 3043084676, 3460867249, 2267602972, 2960053533, 310000809, 1252343602, 3546011162, 874487104, 764276285, 3888056986, 2027650798, 2738126475, 1826865980, 600080766, 1865343845, 2430330616, 800958000, 2190463878, 1631076021, 2696091118, 3500543813, 2307701894, 2851398110, 2537161985, 3625060048, 3578862998, 1301339430, 2126887411, 143130969, 2923730858, 2050701556, 3441906256, 1402282250, 3106136007, 1604931872, 3663181456, 2670487358, 1209839396, 1590843547, 1553686887, 2191470017, 3868594884, 3589872766, 812643747, 307922353, 2443855282, 3121559853, 3489659269, 1987785346}, {3096483504, 1654091471, 672085782, 2896836694, 3680271788, 2771889606, 2129198100, 3843011964, 1883655005, 2137641309, 517055841, 1332662485, 2509548036, 2263673852, 1941818678, 437146728, 2919647160, 2426844043, 4243280403, 1575903278, 1921858715, 3921613942, 3481081141, 724543941, 942196691, 594156836, 919402997, 2663176145, 2302556336, 1418780286, 321105344, 1983503347, 1746436308, 3624258965, 226755747, 18724242, 3878655226, 465509597, 1291370210, 1672857175, 2279028377, 138697712, 1944158794, 601863878, 109884099, 4148938994, 188962623, 3985066587, 4048273890, 2646724450, 3050686093, 2017059222, 1181071395, 950524739, 769773382, 286388612, 407121425, 633750758, 2244066911, 946438008, 1004361455, 638367465, 2798974900, 2454073752}, {909303247, 2564511749, 1797702996, 1265834790, 3412667938, 913911583, 1216824986, 565875211, 674744950, 4022364082, 2906510058, 693490897, 87508789, 816828995, 2768027263, 1945900200, 1917012481, 3955347014, 3643900257, 2901902479, 1336677990, 2616142092, 4232314993, 3096381948, 1607007397, 3314198760, 4253840914, 2143581411, 3038714084, 593510786, 1455588929, 168449529, 2023813954, 1099679361, 506773864, 584507150, 4143179637, 4045820110, 2971588287, 4005790134, 2161010803, 4269813955, 3766046351, 3481930254, 2179958940, 2230711809, 2269757440, 3069978172, 3860496558, 1563593434, 967468853, 665844608, 2542975818, 4251008119, 283071785, 1763346721, 3506409630, 3257131285, 3897653578, 2705785786, 994628912, 2856520859, 1883137474, 726927587}, {1733515325, 3534361163, 1087520572, 2315776215, 1848243034, 2996749864, 2555630738, 485830955, 217548655, 2534554765, 3728409003, 2615729225, 2907357839, 3782185447, 3995994707, 2366774433, 1343254108, 2348103192, 4229177532, 1162303643, 4116228942, 908489814, 3526223930, 1123943097, 2746890296, 2199585491, 1752147332, 403296537, 726768994, 3186602843, 2087824464, 1224380431, 3943471792, 2605321228, 1437114884, 1620694341, 454569999, 461106225, 2786565768, 1489424446, 2827455251, 1823513442, 788398903, 1040846014, 2405717515, 3472092064, 412555411, 3439268152, 3982793845, 2918640562, 1850646671, 957554792, 1919741372, 952101004, 3846649746, 3493442114, 2796159128, 2964856489, 4206537995, 2712276807, 402801575, 1138392575, 2709796832, 1463312390}, {2313417563, 3007600889, 4144722430, 4243097925, 1513661421, 3111848222, 969028459, 866441756, 1424922264, 4244002196, 3942221601, 3783618740, 1165193523, 2896385251, 4238234433, 28250444, 386723821, 272940187, 3380890815, 2215036965, 1041507733, 3177607309, 2433820259, 2936865265, 3527898219, 2081571731, 3922545438, 3323325855, 2119019516, 4019851995, 2708155962, 1732925680, 3362103576, 3607482175, 2578790569, 1815428121, 1592882554, 425940449, 4214633784, 1624288937, 2045521744, 2382348446, 738802945, 683971894, 3640617538, 17416335, 203067975, 669345006, 128542841, 955995594, 2259842595, 2805212965, 2764779394, 2855287416,754154962, 321549603, 507242048, 741913363, 2696725988, 598341890, 1835782736, 1632265602, 614308317, 599996536}, {989827345, 980675395, 476993481, 2301757127, 1035288979, 3915888952, 3887243986, 2960087877, 446594286, 3596266587, 872328074, 3503826317, 1282199541, 3898982719, 3126648466, 3744206320, 3778788537, 1062921524, 2321509267, 3218458749, 2726575308, 1001028205, 570199265, 1818523482, 3873810292, 3183585408, 2384476837, 3474029544, 3513062898, 2055762136, 1241859792, 1870555422, 3824619134, 3486468916, 3367110876, 2614221203, 1904956701, 1375495621, 892843167, 2241520712, 3830080057, 1383249029, 346023965, 2978787461, 3683544186, 3425907617, 1947555715, 1900018350, 1767948230, 290480245, 1287092555, 130935566, 922777843, 3557338705, 3292271777, 3044397157, 3454593883, 2591684895, 888369688, 1382121855, 2223637809, 2843056556, 1235068454, 458675726}, {2654461192, 3664215678, 2299669726, 2671198615, 293743939, 3080044056, 3703969196, 2773347407, 638598270, 35656405, 1344969181, 3308281017, 1291683391, 2169773163, 379593169, 3807327964, 3453488510, 2355204938, 2120188448, 2586342512, 1192734000, 324296064, 1054942264, 3191255693, 1662249921, 3583272659, 809118930, 4194281673, 1547657456, 2444890546, 2687403847, 4228827897, 4131301163, 444472355, 4167102343, 2359608689, 3490450589, 1673839558, 183284375, 930862914, 4194135260, 2580613100, 2608417295, 1592929743, 3879127846, 2790375659, 3786664760, 4279298372, 3234542951, 2725044232, 1046290124, 3393570882, 3181930046, 63080093, 1591870609, 865541307, 1995223572, 3931745851, 1321288411, 192749496, 3621138011, 2012281801, 3392912110, 194479171}, {1149759606, 1840134412, 1938846509, 2625382008, 3358422497, 2539053080, 1628829234, 4007419494, 1209381671, 3084314823, 1340509232, 3368123752, 1351442724, 1956952427, 3926677988, 2913436682, 2922768749, 3467251051, 1877499256, 1392043166, 2101333054, 3847390734, 1151702975, 1990388182, 4109548234, 4103089425, 2659474996, 1972917355, 1005569386, 2377221490, 2090348267, 3185344898, 3731795532, 1926249595, 1061232940, 1270049884, 1050837650, 1210237870, 2384384480, 2204869174, 2001217376, 2259608272, 757467965, 359825348, 3983066778, 2612557029, 615004877, 3798322636, 37944259, 1426117328, 3937543258, 2934836241, 305064451, 242267678, 4172317383, 1732889420, 117672922, 3789210191, 227686623, 450544070, 1243178702, 2640873369, 1337302201, 1618859810}}};
array<array<unsigned long long, 64>, 14> zobrist_64 = {{{2822359641225138343ULL, 9121207143794828849ULL, 5321679401532430870ULL, 10580457069760865127ULL, 11683249146338556464ULL, 9461875794192839216ULL, 12689022705264820933ULL, 7750080359323089672ULL, 12457086792927282350ULL, 12354479828540724772ULL, 58073735091111275ULL, 17600543835393043442ULL, 11418041081640331334ULL, 15473379429572591102ULL, 8551001718173722330ULL, 2931070353223532408ULL, 429576555265488554ULL, 12413700830092660939ULL, 7125838708976106341ULL, 13057243846138972847ULL, 6566376162391932525ULL, 6110208727911861575ULL, 16648703342070669743ULL, 2616313883653657900ULL, 8895390415733893667ULL, 1768565780563543475ULL, 10931176135976102860ULL, 5023576604342806944ULL, 4656121549734877744ULL, 8204218198254092930ULL, 8873752485518465811ULL, 11405181569135036295ULL, 1644580570473058957ULL, 10628055873825943237ULL, 12483629624782647170ULL, 14937140898357366712ULL, 13182319056724122405ULL, 8039637521966276557ULL, 3932097766161245305ULL, 5088604077687489841ULL, 3545796641816050946ULL, 11878759289693300215ULL, 4954690085094861091ULL, 2647306361405473822ULL, 1229722472147115954ULL, 11912999452723285617ULL, 10870805747692187333ULL, 18188385183424303220ULL, 11444083524491683707ULL, 14227436812972521375ULL, 5772044800967255037ULL, 11640432504288662917ULL, 9758264896433163687ULL, 4871005400262434972ULL, 8492433337707585808ULL, 5744727393860756281ULL, 675917210892666609ULL, 13622832577368752266ULL, 1301273801626771493ULL, 13252615632089817559ULL, 9860037798277562592ULL, 2992732369966554460ULL, 11103218921279414933ULL, 16513397183319762892ULL}, {302122248327488253ULL, 5522107043122416689ULL, 2126475559645582964ULL, 84982696925265411ULL, 2739007932153914207ULL, 5657447667884993386ULL, 17240752874805149325ULL, 16786154759512302079ULL, 17459002567988730426ULL, 1257407216540887826ULL, 9728519972775287943ULL, 9262976044553223282ULL, 6070695204759263526ULL, 209183004490814596ULL, 1182862419025269838ULL, 6927908094298786718ULL, 17390762106924846156ULL, 9409667044617827980ULL, 12669919268918827349ULL, 10348888855249127501ULL, 14140041271117680597ULL, 15405564229189620393ULL, 3518693130228558595ULL, 16051552406353784523ULL, 5190739478396026621ULL, 11516365650967186256ULL, 16473392115722312532ULL, 14491492338317661514ULL, 14154705400226247572ULL, 6857697794220507078ULL, 18310612467803421305ULL, 13724098413055575155ULL, 7781916807454103266ULL, 10226391418056723012ULL, 1622019651941455596ULL, 11195125284575303835ULL, 12163335583939598422ULL, 7398817326675353446ULL, 1488376544458036203ULL, 17215831637849602799ULL, 8639836002074381971ULL, 7704146068926038314ULL, 5961887132684402363ULL, 17164555692306144937ULL, 2541340826468580118ULL, 1013019055205041072ULL, 10560732865585331466ULL, 8664838505988000688ULL, 3116377548282752806ULL, 7303617376309376867ULL, 3181569575669844931ULL, 10080142884614151014ULL, 3755760149470682697ULL, 10979655699371463625ULL, 16671533968986086257ULL, 7503053177677472955ULL, 4660911804259542645ULL, 7676143508963001563ULL, 12138956986884098464ULL, 6877929811626453776ULL, 5228469151737672536ULL, 6584548336411294233ULL, 1177429132019839239ULL, 212717932039821401ULL}, {8701223842095058070ULL, 18001630197989333008ULL, 1934585211982121879ULL, 3894770185421857481ULL, 2780439032234538217ULL, 961142302172500329ULL, 4443307115495714599ULL, 17848210440255692506ULL, 3798345375653642655ULL, 5874621039190837442ULL, 12942479627534883168ULL, 7976013510033179031ULL, 15442149900140132798ULL, 333166732037989165ULL, 12529234870102203382ULL, 14086109937222614207ULL, 8018155188398366354ULL, 15773397248578663592ULL, 15846063562502034993ULL, 4817263178887542564ULL, 12338925291827556468ULL, 17792084522468287182ULL, 17714001717004515486ULL, 12680235103875606240ULL, 6367603728541537275ULL, 12741115894167161133ULL, 4748853017091073603ULL, 18253081479618842191ULL, 4229331551293538806ULL, 7780131001919848539ULL, 1476422680502841549ULL, 12921053054137975106ULL, 12198856529875313529ULL, 2588997677762484135ULL, 990593254405004009ULL, 8384834085159555866ULL, 16553793261974628004ULL, 16959753212798728692ULL, 9771014047500372127ULL, 802565102598229030ULL, 5391333615032142374ULL, 2677126096052007909ULL, 9701867220551115269ULL, 13038019565825993416ULL, 12985153041526229632ULL, 191612016614250224ULL, 6597547832508456689ULL, 6253449058402765371ULL, 3598449598113104590ULL, 4775232248408882223ULL, 17221547804286635340ULL, 6581796218555055582ULL, 10014532044151551024ULL, 7495335001531351974ULL, 7822013267462121651ULL, 14566113525940104010ULL, 14444339707744587926ULL, 8671136787893137673ULL, 11108345763586029443ULL, 9867048640746197190ULL, 12525965117682965048ULL, 8114172325428659490ULL, 9589155545814952470ULL, 7700330146516303912ULL}, {13736981614079938125ULL, 15512869293267041696ULL, 8895016297373724851ULL, 15851000108396111144ULL, 16623358357864454529ULL, 16584422591405156026ULL, 7297009073350868089ULL, 17251408823078584937ULL, 11759237953152941235ULL, 12688040063781304402ULL, 94026883007368474ULL, 9891620936186989811ULL, 17385521809887558851ULL, 11825440229917752004ULL, 2776531452136204824ULL, 10811433836581925138ULL, 6949375858809442981ULL, 7073174131113799742ULL, 18421675804582989085ULL, 17779796447067713440ULL, 16606131787667840373ULL, 14579732111112730312ULL, 13951099729318009477ULL, 4144138591001801872ULL, 2864088599012390873ULL, 2040281390196613910ULL, 4016072316155937479ULL, 15980409843098148084ULL, 15885959576149569079ULL, 4386343676474242247ULL, 166765252818413257ULL, 14812415784908527474ULL, 7767570926752770401ULL, 12654604981344118147ULL, 14266963869615724247ULL, 7501073912590853810ULL, 14920452662243033701ULL, 6161543204581280824ULL, 16150006540813289521ULL, 12688722904739600522ULL, 11922029509705364927ULL, 12178397985856151111ULL, 13352656001847725581ULL, 12387038109230350789ULL, 17831654967435933005ULL, 17370571329439650709ULL, 2294560072947878735ULL, 10785622425185574362ULL, 3300101033467308738ULL, 9553626096419319166ULL, 4546472026123713922ULL, 10507425496069028524ULL, 3959790486657229760ULL, 11628383268580804566ULL, 15845071807993484033ULL, 18362009944444343585ULL, 1162167572225363000ULL, 15136286768520174471ULL, 7452772360073858639ULL, 13942028677805993734ULL, 6198262810979640452ULL, 14107381001409577904ULL, 6507836586855945396ULL, 11850640275872680820ULL}, {6443729729648492546ULL, 9539585331221982541ULL, 11000632512031593805ULL, 2565057701698690776ULL, 13897796380099343240ULL, 13434592390238864676ULL, 4356238734117205602ULL, 8735277455162402813ULL, 17983103404501639091ULL, 1821070632377453190ULL, 12114280998579675115ULL, 11864265822386635190ULL, 6107768260201013112ULL, 17934997950860657415ULL, 14440816220868077154ULL, 660844830963655295ULL, 2989250212687744725ULL, 13171979843827493437ULL, 4546696317578625116ULL, 17939773508411441349ULL, 17494966312421270901ULL, 1968266373295257062ULL, 7544621759301776744ULL, 14000508628331582265ULL, 10244080796979869106ULL, 9478484847000073842ULL, 2129432372928293519ULL, 9417557393459920937ULL, 16863231878637424756ULL, 7748338967399613962ULL, 14984571899048001991ULL, 4575025958760744193ULL, 12784508529158673404ULL, 12325442870304224894ULL, 2755080100700761673ULL, 8449743809309888819ULL, 5098384325576376896ULL, 7587446167098035997ULL, 18360336418411300921ULL, 13367528674522464538ULL, 6833130469168265145ULL, 15929535336948033006ULL, 17789722673586877303ULL, 15776623644573072397ULL, 7692131773814745066ULL, 11937190788287123690ULL, 315170667516581189ULL, 3747784290232219683ULL, 12175778545561241624ULL, 8175209955770029025ULL, 7474448099258730026ULL, 2458599599193831547ULL, 5685179670615595817ULL, 4503322774933323744ULL, 15502876702384815772ULL, 13815856578945433426ULL, 4404855227384185605ULL, 17663837454475584983ULL, 15518096076427365451ULL, 1808362263298244075ULL, 17750326139338552711ULL, 14510230892062709574ULL, 11125140934214001686ULL, 1665272866692323826ULL}, {12207005029862263436ULL, 11982833362951485448ULL, 2066999652449391812ULL, 8467790770083534510ULL, 13151813503323547097ULL, 12211593173949880377ULL, 3351650763279421386ULL, 2250746839240075605ULL, 5520298895218728686ULL, 3189838368598220144ULL, 11471782683239632011ULL, 3677923607049017345ULL, 14866640164089534770ULL, 1409099368587284409ULL, 596615786387008563ULL, 6363554548280895523ULL, 12771441439053146401ULL, 8797423794860496071ULL, 9216667320413573880ULL, 11817598390283048323ULL, 4146317307940335717ULL, 4670976482483514518ULL, 9686899707314564576ULL, 7044699954349105552ULL, 15020487275589532965ULL, 10012021690163669044ULL, 4098344057701002408ULL, 12682982369732322797ULL, 14549391144067263080ULL, 15561746883847312379ULL, 14362250493274225179ULL, 10122550505457283756ULL, 14266170850575273868ULL, 2175606452781106401ULL, 10863469006662814608ULL, 5213963642350886318ULL, 6054588212137234330ULL, 14676459905763711341ULL, 1817996340179888507ULL, 7933749902774471388ULL, 9186111275278712376ULL, 12577005224795285034ULL, 5771515482961402085ULL, 11797786874199890104ULL, 15695922331577910297ULL, 2250051507366334037ULL, 6811489710740346611ULL, 4299666063626955887ULL, 7915510076889630259ULL, 2065558917609931381ULL, 467168643492850995ULL, 5807115416493721518ULL, 18128538875077237043ULL, 14814172155704720715ULL, 3220593539875643529ULL, 11651889644317823544ULL, 15203559093086188749ULL, 5706973806624989346ULL, 13117631500280060553ULL, 17494441628767020731ULL, 13923450826942613154ULL, 5599189269184540538ULL, 14256563636093915798ULL, 2427481106611889762ULL}, {18268938165231344065ULL, 8301438434058466954ULL, 17160803306233976322ULL, 1919345979042752392ULL, 4077657451763727248ULL, 7716094625796201462ULL, 9957453743432711742ULL, 14070548889358732602ULL, 658900813460804060ULL, 12356519133336737227ULL, 7174435099455908769ULL, 8890562568615359861ULL, 17444275798765835153ULL, 3872094532835639296ULL, 10664421618689446569ULL, 3364592028498150044ULL, 13355375400149159531ULL, 4351261881392004427ULL, 14760600995545864587ULL, 14239611395577663344ULL, 214640827825862761ULL, 15009850282323046703ULL, 14090715053426064374ULL, 16698608974524247140ULL, 472819360638372899ULL, 4187545541552091394ULL, 1257064977154332542ULL, 12450421005508064853ULL, 15117502385712838793ULL, 1968595199428676426ULL, 2639451410260119801ULL, 122453361635856007ULL, 1591655065631303732ULL, 5863115977496485246ULL, 7998143199519981301ULL, 10883958302790650676ULL, 14219515098418975109ULL, 13675413792169102709ULL, 10723401739806241331ULL, 16493368594406639240ULL, 10617641786664722614ULL, 17751844715847329841ULL, 1629056845846912075ULL, 14897304945820246364ULL, 8830290000995835085ULL, 14183869096184706418ULL, 14490127576244387374ULL, 17034017737625253814ULL, 10068432520427487968ULL, 15391444169902430593ULL, 2007197033478272213ULL, 12022530223816965632ULL, 6339956116461675558ULL, 12730045861617743142ULL, 16255290629788691984ULL, 16496711940273719926ULL, 7362473365533707283ULL, 3009748575583684256ULL, 3379143153152853429ULL, 17545648161102155585ULL, 15522798067041185194ULL, 13742839945022311809ULL, 13768982830630763803ULL, 13475972339491312240ULL}, {12951385773159277801ULL, 7411987788498057983ULL, 16549577675790423211ULL, 3386479950545780426ULL, 897937598323109438ULL, 13667699491620967966ULL, 1571904087736962886ULL, 15098331373972163131ULL, 17088589450033611045ULL, 8135814945282780795ULL, 18316168462611826594ULL, 13685485640897472310ULL, 15789464395542669110ULL, 12759586714550403610ULL, 11553390739127113838ULL, 10882123676392973700ULL, 12527581364058918279ULL, 12322659230817764382ULL, 15558579144437685638ULL, 7669975468240521815ULL, 13085161544204299387ULL, 17810510853693067517ULL, 11951513463204479687ULL, 975287630877970877ULL, 9181158798614430804ULL, 106624682207509353ULL, 17781081666670964313ULL, 5387093083170174005ULL, 9702407697985634674ULL, 7799358031092454075ULL, 17234898960080997907ULL, 11026081063773403729ULL, 12132630552897371986ULL, 2946840127860313138ULL, 6943453469587653108ULL, 3014247257939034266ULL, 13003061117731381606ULL, 3846424244675814589ULL, 5596781873304093424ULL, 90475480379979410ULL, 27460932264260364ULL, 4981445101081842800ULL, 14983815697128697712ULL, 12069652301421769155ULL, 15904670007398270980ULL, 1987696418956959145ULL, 8196805262026241551ULL, 12639512119229142836ULL, 15348324532681961656ULL, 15055565464256031181ULL, 6161511535004895878ULL, 6706221932601854521ULL, 707930702978778711ULL, 3404287046665639249ULL, 12854854435779802394ULL, 10742107266369389181ULL, 11673540895423096824ULL, 4983260171326485020ULL, 14531375956834719490ULL, 17135953146277116467ULL, 4196442129043189777ULL, 3962110256307317145ULL, 7202907604851509612ULL, 14019014964239159424ULL}, {16110021564884853783ULL, 811348168354836622ULL, 6856513240843464527ULL, 17208431110914144313ULL, 13881873058332443463ULL, 234973032679031566ULL, 1923707439606715495ULL, 5092767582626287360ULL, 859903114429914927ULL, 18087710624534754138ULL, 3350644743727304109ULL, 18191996147665894664ULL, 9552036753767813228ULL, 16660711512872947378ULL, 10787831203818580874ULL, 11638659676896471466ULL, 7947925122372489625ULL, 4987396799181971915ULL, 14351258643366717788ULL, 3272420361855584443ULL, 8344323332480885852ULL, 10757699002458256211ULL, 17804818140687561419ULL, 6821896396420623838ULL, 1156473206769243708ULL, 13261485406271355208ULL, 3572113464746822351ULL, 3315288177922117626ULL, 8241436346895276948ULL, 4606949135729595403ULL, 12886725868823970196ULL, 13861677161679999064ULL, 2923330921751918185ULL, 8314636284278282852ULL, 14632447777172788417ULL, 14595680672373741697ULL, 8673997297188341967ULL, 888435903938220742ULL, 10527778530109273927ULL, 8033465113875397737ULL, 664131721199080019ULL, 15960603552063286804ULL, 17018795723264878309ULL, 5266134927580282534ULL, 1744334464413788635ULL, 3385247289895097992ULL, 1355203173930531893ULL, 2301176027198704488ULL, 3856295494182978811ULL, 6010597364536142905ULL, 1677152673220091102ULL, 7911175460902392295ULL, 14452944755851665252ULL, 3916942379446101065ULL, 5009831516831691421ULL, 11308996412847890329ULL, 13395535954799474676ULL, 5418605770615523841ULL, 8045554624443522971ULL, 16064933131001735876ULL, 6414862479367318471ULL, 8258982223229462153ULL, 10003434501942447395ULL, 2995714195787614837ULL}, {1249076206431819567ULL, 4060321495335294903ULL, 11367433385541911094ULL, 5869034872012071543ULL, 14255443002680886838ULL, 3661242412100516442ULL, 10409612589698878395ULL, 13251495652176768526ULL, 17810967414995693013ULL, 5979666734574447108ULL, 3182764851267975073ULL, 13313409639874122855ULL, 14148559930411165290ULL, 3407261045396192628ULL, 10391618568077589298ULL, 14574585082833243555ULL, 3675355397725824458ULL, 9226234071871512550ULL, 13489265670818146060ULL, 3262606206137305311ULL, 9453673212723942427ULL, 2735406134724369105ULL, 551133806055798400ULL, 13258654663269155407ULL, 17375249707733020316ULL, 8602922696543509610ULL, 13951412173145273085ULL, 12053278437103295086ULL, 8424152515562705991ULL, 17208581509805554862ULL, 1314493776169236276ULL, 5696722960870133061ULL, 15635670425700971411ULL, 6913295273238702570ULL, 12295241526900302631ULL, 6576599650007138167ULL, 12746821414245624530ULL, 6338462168883324307ULL, 5793427213914745239ULL, 9581518492467161631ULL, 13580699755093104744ULL, 6024090362241728129ULL, 7103902671112806083ULL, 4100234782974294290ULL, 13517987460525166875ULL, 11209192323932451300ULL, 9768783783017243214ULL, 6061148373340957370ULL, 17288115733542943232ULL, 2660031025488111949ULL, 617830380981645217ULL, 2159355588467956475ULL, 15225128167062289154ULL, 16914276161977787371ULL, 7322542317826826650ULL, 10451649402565130060ULL, 275650309965563314ULL, 5102069429258672174ULL, 17190699969708414948ULL, 950846719940611757ULL, 12655121009655514138ULL, 5237617155722352060ULL, 17488725582275383381ULL, 2010641025787749970ULL}, {2743485075815863941ULL, 9369273924860812884ULL, 4422130305746787875ULL, 8932202208157350233ULL, 7904496152741470290ULL, 14131423563899915445ULL, 15688586233787779155ULL, 14060745477911778761ULL, 10285359555995362858ULL, 13945105103868686719ULL, 16501703707275070134ULL, 16426806844535154752ULL, 338195674168507172ULL, 14835517102853999611ULL, 7314492748369652165ULL, 11700918129085551795ULL, 14655470138853402972ULL, 13536490041872638414ULL, 16440349239271172767ULL, 11081538730043202067ULL, 7256927428710638069ULL, 14347843468959603919ULL, 12534890667272903565ULL, 9323035877197964856ULL, 7111946386988646786ULL, 5640816981547759659ULL, 12601892105578402707ULL, 12341575567398041425ULL, 9626778683918431751ULL, 7111051383412334088ULL, 8952013636769028175ULL, 17061948350020773314ULL, 15819927495322495446ULL, 16779635282452070237ULL, 15422501613642263878ULL, 6230852906788404245ULL, 14851858798986706357ULL, 5606685229499956717ULL, 5728194027857157926ULL, 15835503172940424176ULL, 15168972866137971003ULL, 16505371275150242696ULL, 9219599881860906167ULL, 2479309291483092354ULL, 1508124176527774810ULL, 156027226058362945ULL, 16713478343937600364ULL, 14386423741114630292ULL, 4291202520270701278ULL, 16733640647850684753ULL, 4838626741646768599ULL, 12892632209146419574ULL, 177051454267932929ULL, 3254774798118434956ULL, 12465198450644030063ULL, 9732919682960350388ULL, 11536924137749937376ULL, 9396109054851447184ULL, 803301694742554531ULL, 17366912294063472317ULL, 7880691044793744618ULL, 1574037671075872915ULL, 13613656371794453750ULL, 15031107354270635225ULL}, {14934092868311220554ULL, 7109761981536694518ULL, 1638392423689505184ULL, 14102066939911990900ULL, 11151339627329564675ULL, 5100516059022054566ULL, 14420127569456658259ULL, 1666718348737611054ULL, 10196945021522548589ULL, 3554013250914701395ULL, 1661209311930076657ULL, 8811211482960812249ULL, 15818414140635843896ULL, 18369055814510500927ULL, 2253126678721133574ULL, 13136916716372181964ULL, 4950789645498003661ULL, 13909369892716413467ULL, 9756183427152932778ULL, 13131777934996959034ULL, 5670262521548395891ULL, 1941300923767113255ULL, 1826439631202993394ULL, 11733301553019376965ULL, 12906600520742787780ULL, 2570500427959545588ULL, 13067012943574064865ULL, 1423006118441769427ULL, 15361543562615666485ULL, 9097733257845105195ULL, 16253868879011276392ULL, 3230320565280262599ULL, 17146209157898946449ULL, 14967874553913132783ULL, 12563457093400895576ULL, 13207401708956289663ULL, 8173890414677946395ULL, 948248148086610819ULL, 13561503971636164272ULL, 12779405109188380657ULL, 10642594240890781832ULL, 6559471275985623451ULL, 3311343150276307791ULL, 4376770370481061291ULL, 4004546867739616449ULL, 14939532754070063943ULL, 13376566486294601721ULL, 15049249132243415067ULL, 12027208357160065048ULL, 9152900536020886541ULL, 3555721704273874337ULL, 3455697134349724480ULL, 12111070651642814428ULL, 11185143171628901465ULL, 2642551291823325906ULL, 7693857864394641845ULL, 5678420174571015470ULL, 2399787948935887389ULL, 13231929965991943018ULL, 10413183163076523629ULL, 6424978980842539199ULL, 4005280782712374410ULL, 9618787049308028558ULL, 8897347304109881156ULL}, {10950944410964289605ULL, 342280686341905793ULL, 8239653189094391248ULL, 12955745663205910548ULL, 15362568709131787620ULL, 14948087170201421047ULL, 12543329596036838589ULL, 16341195981751618486ULL, 3106829917367817109ULL, 15416176896893297220ULL, 709499730676124308ULL, 17887665268173229313ULL, 13815455196734542721ULL, 395222245996786887ULL, 9656747635564339886ULL, 16872211338908081732ULL, 15795916667760551546ULL, 5906423196317500424ULL, 6339508221343387466ULL, 9902707539028452533ULL, 6957134633946275926ULL, 799146629096566438ULL, 17464045816203512176ULL, 14338815450299632363ULL, 4273359636925252041ULL, 3804172340348959427ULL, 3931825397405316558ULL, 9630714624895288876ULL, 5837951928045145960ULL, 6320794422423720962ULL, 4178327888251174511ULL, 14726230472124190529ULL, 1653618810333641793ULL, 1045163978882233018ULL, 998991668679593679ULL, 6936011363148899046ULL, 9521071749057756789ULL, 10158416885830921030ULL, 9593414798792410340ULL, 16372527788563368985ULL, 8707988213997609806ULL, 8145825071817274566ULL, 9776105288063579573ULL, 13614005603659167541ULL, 17606662510717767864ULL, 4429056658401474138ULL, 8213740865451973855ULL, 923690206441928844ULL, 10795069633768509910ULL, 1524786536510389562ULL, 6235411484871784910ULL, 12819473953271630129ULL, 3885704242789390021ULL, 17117626222733585951ULL, 3167938751790452050ULL, 12179053641378158015ULL, 8564395901774329444ULL, 17147590226479285158ULL, 17030256970593881508ULL, 416584805276784644ULL, 18133449611126571240ULL, 4287910451451202990ULL, 521243406739131937ULL, 7036775774659619745ULL}, {10479902829313734140ULL, 3789260612576629282ULL, 15699544273260304454ULL, 7216773647748705872ULL, 7522078545398396588ULL, 14447017459361803991ULL, 5341350398015911536ULL, 3493017476476390246ULL, 11183969068295613195ULL, 10656463939391588589ULL, 2632578937714583945ULL, 12113776171446784714ULL, 16240445631619810642ULL, 1265820683684680749ULL, 5651059276022792916ULL, 13017651171390228304ULL, 5368033016659821299ULL, 83946607604881680ULL, 7823149446187892519ULL, 5672245771282005653ULL, 4763209193536563957ULL, 1332962043947731110ULL, 2927841399782885267ULL, 17275410924710918419ULL, 3733275491742073027ULL, 4373655574574159778ULL, 16368607742857785299ULL, 1404841990020883191ULL, 16674513138476825483ULL, 14458204395804263329ULL, 8354412123106868072ULL, 13522551819463712047ULL, 13859699960028391777ULL, 164110874105342329ULL, 6253804224576522297ULL, 9414475277303216940ULL, 443877787477904461ULL, 3052873895526992712ULL, 11714239875405496739ULL, 8058325628008785952ULL, 15732253686587720678ULL, 16549891046666675917ULL, 3014847246040156532ULL, 13961905363345947185ULL, 15790980051752508187ULL, 2972249625179409558ULL, 4224748348090095568ULL, 12407721272124796907ULL, 17098264305884384119ULL, 4121341083779620788ULL, 3546093776341385172ULL, 5561365817962664109ULL, 4728504256031120728ULL, 5579926658703298127ULL, 3970237371649072566ULL, 13152346365406565745ULL, 13265843851200890178ULL, 17773262506483610523ULL, 12638056061153527242ULL, 4954250611320349782ULL, 5144370397108772844ULL, 1641219873897581389ULL, 1298174178023239616ULL, 3141761230294706751ULL}}};
array<array<unsigned long long, 64>, 14> zobrist = zobrist_64;

unordered_map<unsigned long long, int> hash_table;

unsigned long long first_one(unsigned long long x){
  if (x == 0) {return 0;};
  return (x ^ (x - 1)) & x;
}



unsigned long long last_one(unsigned long long x){
  if (x == 0) {return 0;};
   x |= x >> 1;
   x |= x >> 2;
   x |= x >> 4;
   x |= x >> 8;
   x |= x >> 16;
   x |= x >> 32;
  return (x >> 1) + 1;
}



const array<int, 64> index64 = {
    0, 47,  1, 56, 48, 27,  2, 60,
   57, 49, 41, 37, 28, 16,  3, 61,
   54, 58, 35, 52, 50, 42, 21, 44,
   38, 32, 29, 23, 17, 11,  4, 62,
   46, 55, 26, 59, 40, 36, 15, 53,
   34, 51, 20, 43, 31, 22, 10, 45,
   25, 39, 14, 33, 19, 30,  9, 24,
   13, 18,  8, 12,  7,  6,  5, 63};

const unsigned long long debruijn64 = 285870213051386505ULL;

int bitScanForward(unsigned long long x) {
   if (x == 0) {return 64;}
   return index64[((x ^ (x - 1)) * debruijn64) >> 58];
}



int bitScanReverse(unsigned long long x) {
   if (x == 0) {return 64;};
   x |= x >> 1;
   x |= x >> 2;
   x |= x >> 4;
   x |= x >> 8;
   x |= x >> 16;
   x |= x >> 32;
   return index64[(x * debruijn64) >> 58];
}



int Population(unsigned long long x){
  int count = 0;
  while(x){
    count ++;
    x ^= first_one(x);
  }
  return count;
}


pair<pair<array<unsigned long long, 16>, multiset<unsigned long long>>, pair<array<int, 3>, unsigned long long>> position_recount(pair<pair<array<unsigned long long, 16>, multiset<unsigned long long>>, pair<array<int, 3>, unsigned long long>> position){
  position.second = {{0, 0, 0}, 0};
  for (int i = 0; i < 12; i++){
    for (int j = 0; j < 64; j++){
      if (position.first.first[i] & one_mask[j]){
        position.second.first[0] += piece_square_tables[0][i][j];
        position.second.first[1] += piece_square_tables[1][i][j];
        if (i % 6 != 5 and i % 6 != 0){
          position.second.first[2] += material_costs[i % 6];
        }
        position.second.second ^= zobrist[i][j];
      }
    }
  }
  for (int j = 0; j < 64; j++){
      if (position.first.first[15] & one_mask[j]){
        position.second.second ^= zobrist[13][j];
      }
    }
   for (int j = 0; j < 5; j++){
      if (position.first.first[12] & one_mask[j]){
        position.second.second ^= zobrist[12][j];
      }
    }
  return position;
}


string bitboards_to_FEN (pair<pair<array<unsigned long long, 16>, multiset<unsigned long long>>, pair<array<int, 3>, unsigned long long>> position){
  array<array<int, 8>, 8> position_print;
  for (int k = 0; k < 8; k++){
    fill(position_print[k].begin(), position_print[k].end(), 12);
  }
  for (int i = 0; i < 12; i++){
    for (int j = 0; j < 64; j++){
      if ((one_mask[j]) & position.first.first[i]){
        position_print[7 - int(j / 8)][j % 8] = i;
      }
    }
  }
  array<char, 12> pieces = {'P', 'N', 'B', 'R', 'Q', 'K', 'p', 'n', 'b', 'r', 'q', 'k'};
  string FEN = "";
  int empty_squares = 0;
  for (int i = 0; i < 8; i++){
    for (int j = 0; j < 8; j++){
      if (position_print[i][j] == 12){
        empty_squares ++;
      }
      else{
        if (empty_squares > 0){
          FEN += to_string(empty_squares);
          empty_squares = 0;
        }
        FEN += pieces[position_print[i][j]];
      }
    }
    if (empty_squares > 0){
      FEN += to_string(empty_squares);
      empty_squares = 0;
    }
    if (i != 7) {FEN += "/";}
  }
  if (position.first.first[12] & 16ULL) {
    FEN += " w ";
  }
  else {
    FEN += " b ";
  }
  if (position.first.first[12] & 8ULL) {FEN += "K";}
  if (position.first.first[12] & 4ULL) {FEN += "Q";}
  if (position.first.first[12] & 2ULL) {FEN += "k";}
  if (position.first.first[12] & 1ULL) {FEN += "q";}
  if (not(position.first.first[12] & 15ULL)) {FEN += "-";}
  array<string, 8> letters = {"a", "b", "c", "d", "e", "f", "g", "h"};
  if (position.first.first[15] == 0) {FEN += " - ";}
  else {int square = bitScanForward(position.first.first[15]); FEN += " " + letters[square % 8] + to_string((square / 8) + 1) + " ";}
  FEN += to_string(position.first.first[12] >> 5);
  FEN += " " + to_string((history.size() - 1) / 2 + 1);
  return FEN;
}


pair<pair<array<unsigned long long, 16>, multiset<unsigned long long>>, pair<array<int, 3>, unsigned long long>> FEN_to_bitboards(string FEN){
  array<unsigned long long, 16> bitboards = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
  int i = 0;
  int j = 56;
  array<char, 12> pieces = {'P', 'N', 'B', 'R', 'Q', 'K', 'p', 'n', 'b', 'r', 'q', 'k'};
  array<char, 8> numbers = {'1', '2', '3', '4', '5', '6', '7', '8'};
  while (FEN[i] != ' '){
    if (FEN[i] == '/'){
      i ++;
      j -= 16;
      continue;
    }
    auto piece = find(pieces.begin(), pieces.end(), FEN[i]);
    auto num = find(numbers.begin(), numbers.end(), FEN[i]);
    if (piece != pieces.end()){
      bitboards[piece - pieces.begin()] |= one_mask[j];
      if (piece - pieces.begin() <= 5){
        bitboards[13] |= one_mask[j];
      }
      else {
        bitboards[14] |= one_mask[j];
      }
      j++;
      i++;
      continue;
    }
    if (num != numbers.end()){
      j += (num - numbers.begin()) + 1;
      i++;
      continue;
    }
  }
  i++;
  if (FEN[i] == 'w'){
    bitboards[12] |= 16ULL;
  }
  i += 2;
  if (FEN[i] == 'K') {bitboards[12] |= 8ULL; i++;}
  if (FEN[i] == 'Q') {bitboards[12] |= 4ULL; i++;}
  if (FEN[i] == 'k') {bitboards[12] |= 2ULL; i++;}
  if (FEN[i] == 'q') {bitboards[12] |= 1ULL; i++;}
  if (FEN[i] == '-') {i += 2;} else {i++;}
  if (FEN[i] == '-') {i += 2;} else {
    int square = FEN[i] - 'a' + (FEN[i + 1] - '1') * 8;
    bitboards[15] = one_mask[square];
    i += 3;
  }
  int x = 0;
  while (FEN[i] != ' '){
    x = x * 10 + (FEN[i] - '0');
    i++;
  }
  bitboards[12] += x * 32;
  pair<pair<array<unsigned long long, 16>, multiset<unsigned long long>>, pair<array<int, 3>, unsigned long long>> ans = {{bitboards, {}}, {{0, 0, 0}, 0}};
  ans = position_recount(ans);
  return ans;
}


void print_position(pair<pair<array<unsigned long long, 16>, multiset<unsigned long long>>, pair<array<int, 3>, unsigned long long>> position, int style = board_style){
  if (style == 0){
    cout << endl;
    array<array<int, 8>, 8> position_print;
    int x;
    for (int k = 0; k < 8; k++){
      fill(position_print[k].begin(), position_print[k].end(), 0);
    }
    for (int i = 0; i < 12; i++){
      for (int j = 0; j < 64; j++){
        if ((one_mask[j]) & position.first.first[i]){
          if (i < 6){x = i + 1;}
          else{x = - i + 5;}
          position_print[7 - int(j / 8)][j % 8] = x;
        }
      }
    }
    for (int i = 0; i <= 7; i++)
    {
      for (int j = 0; j <= 7; j++)
      {
        if (position_print[i][j] >= 0) {cout << " ";}
        cout << int(position_print[i][j]) << " ";
      }
      cout << endl;
    }
    cout << endl;
    cout << ((position.first.first[12] >> 3) & 1ULL);
    cout << ((position.first.first[12] >> 2) & 1ULL);
    cout << ((position.first.first[12] >> 1) & 1ULL);
    cout << ((position.first.first[12] >> 0) & 1ULL) << ' ';
    cout << ((position.first.first[12] >> 4) & 1ULL) << ' ';
    cout << (position.first.first[12] >> 5) << ' ';
    for (auto k: position.second.first){cout << k << ' ';}
    cout << endl << endl;
  }
  else if (style == 1){
    cout << endl;
    array<array<int, 8>, 8> position_print;
    for (int k = 0; k < 8; k++){
      fill(position_print[k].begin(), position_print[k].end(), 12);
    }
    for (int i = 0; i < 12; i++){
      for (int j = 0; j < 64; j++){
        if ((one_mask[j]) & position.first.first[i]){
          position_print[7 - int(j / 8)][j % 8] = i;
        }
      }
    }
    array<char, 13> pices = {'P', 'N', 'B', 'R', 'Q', 'K', 'p', 'n', 'b', 'r', 'q', 'k', ' '};
    for (int i = 0; i <= 7; i++){
      cout << "+---+---+---+---+---+---+---+---+  \n";
      for (int j = 0; j <= 7; j++){
        cout << "| " << pices[position_print[i][j]] << " ";
      }
      cout << "| " << 8 - i << "\n";
    }
    cout << "+---+---+---+---+---+---+---+---+  \n  a   b   c   d   e   f   g   h    \n";
    cout << endl;
    cout << "FEN: " << bitboards_to_FEN(position) << endl << endl;
  }
}

void print_bitboard(unsigned long long bitboard){
  cout << endl;
  for (int i = 0; i < 64; i++){
    cout << ((bitboard >> (8 * (7 - int(i / 8)) + i % 8)) & 1ULL) << " ";
    if (i % 8 == 7){cout << endl;}
  }
}



void print_move(int move){
  array<char, 6> pieces = {'p', 'n', 'b', 'r', 'q', 'k'};
  if (move == 20868) {cout << "O-O ";}
  else if (move == 20612) {cout << "O-O-O ";}
  else if (move == 24508) {cout << "O-O ";}
  else if (move == 24252) {cout << "O-O-O ";}
  else{
    cout << char('a' + (move & 63) % 8) << char('1' + (move & 63) / 8) << " ";
    move >>= 6;
    cout << char('a' + (move & 63) % 8) << char('1' + (move & 63) / 8) << " ";
    move >>= 9;
    if (move) {cout << pieces[move] << ' ';}
  }
  return;
}



bool Check(const pair<pair<array<unsigned long long, 16>, multiset<unsigned long long>>, pair<array<int, 3>, unsigned long long>>& position, int tomove_ = 100){
  int tomove = tomove_;
  if (tomove_ == 100) {tomove = ((position.first.first[12] >> 4) & 1ULL) * (-6) + 6;}
  tomove = -tomove + 6;
  int king_position = bitScanForward(position.first.first[11 - tomove]);
  if (king_position == 64){return true;}
  if (knight_moves[king_position] & position.first.first[1 + tomove]){return true;}
  if (king_moves[king_position] & position.first.first[5 + tomove]){return true;}
  if (tomove == 6 and ((left_up_ray[king_position] | right_up_ray[king_position]) &
    king_moves[king_position] & position.first.first[6])){return true;}
  if (tomove == 0 and ((left_down_ray[king_position] | right_down_ray[king_position]) &
    king_moves[king_position] & position.first.first[0])){return true;}
  unsigned long long pieces = position.first.first[13] | position.first.first[14];
  if (first_one(right_ray[king_position] & pieces) &
    (position.first.first[3 + tomove] | position.first.first[4 + tomove])){return true;}
  if (last_one(left_ray[king_position] & pieces) &
    (position.first.first[3 + tomove] | position.first.first[4 + tomove])){return true;}
  if (first_one(up_ray[king_position] & pieces) &
    (position.first.first[3 + tomove] | position.first.first[4 + tomove])){return true;}
  if (last_one(down_ray[king_position] & pieces) &
    (position.first.first[3 + tomove] | position.first.first[4 + tomove])){return true;}
  if (first_one(right_up_ray[king_position] & pieces) &
    (position.first.first[2 + tomove] | position.first.first[4 + tomove])){return true;}
  if (last_one(right_down_ray[king_position] & pieces) &
    (position.first.first[2 + tomove] | position.first.first[4 + tomove])){return true;}
  if (first_one(left_up_ray[king_position] & pieces) &
    (position.first.first[2 + tomove] | position.first.first[4 + tomove])){return true;}
  if (last_one(left_down_ray[king_position] & pieces) &
    (position.first.first[2 + tomove] | position.first.first[4 + tomove])){return true;}
  return false;
}



unsigned long long PawnMoves(const pair<pair<array<unsigned long long, 16>, multiset<unsigned long long>>, pair<array<int, 3>, unsigned long long>>& position, int square){
  if ((position.first.first[12] >> 4) & 1ULL) {
    unsigned long long ans = 0ULL;
    ans |= (one_mask[square + 8]) & ~(position.first.first[13] | position.first.first[14]);
    ans |= (ans << 8) & ~(position.first.first[13] | position.first.first[14]) & RANK_4;
    ans |= (one_mask[square + 7]) & ~RANK_H & (position.first.first[14] | position.first.first[15]);
    ans |= (one_mask[square + 9]) & ~RANK_A & (position.first.first[14] | position.first.first[15]);
    return ans;
  }
  unsigned long long ans = 0ULL;
  ans |= (one_mask[square - 8]) & ~(position.first.first[13] | position.first.first[14]);
  ans |= (ans >> 8) & ~(position.first.first[13] | position.first.first[14]) & RANK_5;
  ans |= (one_mask[square - 7]) & ~RANK_A & (position.first.first[13] | position.first.first[15]);
  ans |= (one_mask[square - 9]) & ~RANK_H & (position.first.first[13] | position.first.first[15]);
  return ans;
}



unsigned long long KnightMoves(const pair<pair<array<unsigned long long, 16>, multiset<unsigned long long>>, pair<array<int, 3>, unsigned long long>>& position, int square){
  return knight_moves[square] & ~(position.first.first[14 - ((position.first.first[12] >> 4) & 1ULL)]);
}



unsigned long long BishopMoves(const pair<pair<array<unsigned long long, 16>, multiset<unsigned long long>>, pair<array<int, 3>, unsigned long long>>& position, int square){
  unsigned long long ans = 0ULL;
  unsigned long long pieces = position.first.first[13] | position.first.first[14];
  ans |= right_up_ray[bitScanForward(right_up_ray[square] & pieces)] ^ right_up_ray[square];
  ans |= left_up_ray[bitScanForward(left_up_ray[square] & pieces)] ^ left_up_ray[square];
  ans |= right_down_ray[bitScanReverse(right_down_ray[square] & pieces)] ^ right_down_ray[square];
  ans |= left_down_ray[bitScanReverse(left_down_ray[square] & pieces)] ^ left_down_ray[square];
  return ans & ~(position.first.first[14 - ((position.first.first[12] >> 4) & 1ULL)]);
}



unsigned long long RookMoves(const pair<pair<array<unsigned long long, 16>, multiset<unsigned long long>>, pair<array<int, 3>, unsigned long long>>& position, int square){
  unsigned long long ans = 0ULL;
  unsigned long long pieces = position.first.first[13] | position.first.first[14];
  ans |= right_ray[bitScanForward(right_ray[square] & pieces)] ^ right_ray[square];
  ans |= left_ray[bitScanReverse(left_ray[square] & pieces)] ^ left_ray[square];
  ans |= down_ray[bitScanReverse(down_ray[square] & pieces)] ^ down_ray[square];
  ans |= up_ray[bitScanForward(up_ray[square] & pieces)] ^ up_ray[square];
  return ans & ~(position.first.first[14 - ((position.first.first[12] >> 4) & 1ULL)]);
}



unsigned long long QueenMoves(const pair<pair<array<unsigned long long, 16>, multiset<unsigned long long>>, pair<array<int, 3>, unsigned long long>>& position, int square){
  return BishopMoves(position, square) | RookMoves(position, square);
}


unsigned long long KingMoves(pair<pair<array<unsigned long long, 16>, multiset<unsigned long long>>, pair<array<int, 3>, unsigned long long>> position, int square){
  int tomove = ((position.first.first[12] >> 4) & 1ULL) * (-1) + 1;
  unsigned long long ans = king_moves[square] & ~position.first.first[13 + tomove];
  if (Check(position)){return ans;}
  unsigned long long pieces = position.first.first[13] | position.first.first[14];
  position.first.first[5 + tomove * 6] <<= 1;
  if (position.first.first[12] & one_mask[3 - 2 * tomove] and not(Check(position)) and
  not(pieces & (6ULL << square))){ans |= one_mask[square + 2];}
  position.first.first[5 + tomove * 6] >>= 2;
  if (position.first.first[12] & one_mask[2 - 2 * tomove] and (not(Check(position)) and
  not(pieces & (7ULL << (square - 3))))) {ans |= one_mask[square - 2];}
  return ans;
}


unsigned long long KnightAttacks(const pair<pair<array<unsigned long long, 16>, multiset<unsigned long long>>, pair<array<int, 3>, unsigned long long>>& position, int square){
  return knight_moves[square];
}



unsigned long long BishopAttacks(const pair<pair<array<unsigned long long, 16>, multiset<unsigned long long>>, pair<array<int, 3>, unsigned long long>>& position, int square){
  unsigned long long ans = 0ULL;
  unsigned long long pieces = position.first.first[13] | position.first.first[14];
  ans |= right_up_ray[bitScanForward(right_up_ray[square] & pieces)] ^ right_up_ray[square];
  ans |= left_up_ray[bitScanForward(left_up_ray[square] & pieces)] ^ left_up_ray[square];
  ans |= right_down_ray[bitScanReverse(right_down_ray[square] & pieces)] ^ right_down_ray[square];
  ans |= left_down_ray[bitScanReverse(left_down_ray[square] & pieces)] ^ left_down_ray[square];
  return ans;
}



unsigned long long RookAttacks(const pair<pair<array<unsigned long long, 16>, multiset<unsigned long long>>, pair<array<int, 3>, unsigned long long>>& position, int square){
  unsigned long long ans = 0ULL;
  unsigned long long pieces = position.first.first[13] | position.first.first[14];
  ans |= right_ray[bitScanForward(right_ray[square] & pieces)] ^ right_ray[square];
  ans |= left_ray[bitScanReverse(left_ray[square] & pieces)] ^ left_ray[square];
  ans |= down_ray[bitScanReverse(down_ray[square] & pieces)] ^ down_ray[square];
  ans |= up_ray[bitScanForward(up_ray[square] & pieces)] ^ up_ray[square];
  return ans;
}



unsigned long long QueenAttacks(const pair<pair<array<unsigned long long, 16>, multiset<unsigned long long>>, pair<array<int, 3>, unsigned long long>>& position, int square){
  return BishopAttacks(position, square) | RookAttacks(position, square);
}




unsigned long long PawnTakes(const pair<pair<array<unsigned long long, 16>, multiset<unsigned long long>>, pair<array<int, 3>, unsigned long long>>& position, int square){
  if ((position.first.first[12] >> 4) & 1ULL) {
    unsigned long long ans = 0ULL;
  
    ans |= (one_mask[square + 7]) & ~RANK_H & (position.first.first[14] | position.first.first[15]) ;
    ans |= (one_mask[square + 9]) & ~RANK_A & (position.first.first[14] | position.first.first[15]);
    ans |= (one_mask[square + 8]) & ~(position.first.first[13] | position.first.first[14]) & RANK_8;
    return ans;
  }
  unsigned long long ans = 0ULL;
  ans |= (one_mask[square - 7]) & ~RANK_A & (position.first.first[13] | position.first.first[15]) ;
  ans |= (one_mask[square - 9]) & ~RANK_H & (position.first.first[13] | position.first.first[15]);
  ans |= (one_mask[square - 8]) & ~(position.first.first[13] | position.first.first[14]) & RANK_1;
  return ans;
}



unsigned long long KnightTakes(const pair<pair<array<unsigned long long, 16>, multiset<unsigned long long>>, pair<array<int, 3>, unsigned long long>>& position, int square){
  return knight_moves[square] & position.first.first[13 + ((position.first.first[12] >> 4) & 1ULL)];
}



unsigned long long BishopTakes(const pair<pair<array<unsigned long long, 16>, multiset<unsigned long long>>, pair<array<int, 3>, unsigned long long>>& position, int square){
  unsigned long long ans = 0ULL;
  unsigned long long pieces = position.first.first[13] | position.first.first[14];
  ans |= first_one(right_up_ray[square] & pieces);
  ans |= first_one(left_up_ray[square] & pieces);
  ans |= last_one(right_down_ray[square] & pieces);
  ans |= last_one(left_down_ray[square] & pieces);
  return ans & position.first.first[13 + ((position.first.first[12] >> 4) & 1ULL)];
}



unsigned long long RookTakes(const pair<pair<array<unsigned long long, 16>, multiset<unsigned long long>>, pair<array<int, 3>, unsigned long long>>& position, int square){
  unsigned long long ans = 0ULL;
  unsigned long long pieces = position.first.first[13] | position.first.first[14];
  ans |= first_one(right_ray[square] & pieces);
  ans |= last_one(left_ray[square] & pieces);
  ans |= last_one(down_ray[square] & pieces);
  ans |= first_one(up_ray[square] & pieces);
  return ans & position.first.first[13 + ((position.first.first[12] >> 4) & 1ULL)];
}



unsigned long long QueenTakes(const pair<pair<array<unsigned long long, 16>, multiset<unsigned long long>>, pair<array<int, 3>, unsigned long long>>& position, int square){
  return BishopTakes(position, square) | RookTakes(position, square);
}



unsigned long long KingTakes(const pair<pair<array<unsigned long long, 16>, multiset<unsigned long long>>, pair<array<int, 3>, unsigned long long>>& position, int square){
  return king_moves[square] & position.first.first[13 + ((position.first.first[12] >> 4) & 1ULL)];
}



pair<pair<array<unsigned long long, 16>, multiset<unsigned long long>>, pair<array<int, 3>, unsigned long long>> MakeMove(pair<pair<array<unsigned long long, 16>, multiset<unsigned long long>>, pair<array<int, 3>, unsigned long long>> position, int move, int captured_piece = -1){
  if (move == 0) {position.first.first[12] ^= one_mask[4]; return position;}
  int tomove1 = ((position.first.first[12] >> 4) & 1ULL) * (-1) + 1;
  int tomove = tomove1 * 6;
  int from = move & 63;
  int to = (move >> 6) & 63;
  int piece = ((move >> 12) & 7) + tomove;
  int promotion = (move >> 15) & 7;
  if (promotion != 0) {promotion += tomove;}
  bool capture = position.first.first[14 - tomove1] & one_mask[to];
  position.first.first[13 + tomove1] ^= one_mask[from] | one_mask[to];
  position.first.first[14 - tomove1] &= ~one_mask[to];
  position.first.first[piece] ^= one_mask[from] | one_mask[to];
  position.second.second ^= zobrist[piece][from] ^ zobrist[piece][to];
  position.second.first[0] += piece_square_tables[0][piece][to] - piece_square_tables[0][piece][from];
  position.second.first[1] += piece_square_tables[1][piece][to] - piece_square_tables[1][piece][from];
  if (piece == tomove and (one_mask[to] & position.first.first[15])) {
    if (position.first.first[6 - tomove] & one_mask[to + 8]){position.second.first[0] -= piece_square_tables[0][6 - tomove][to + 8];
                                                             position.second.first[1] -= piece_square_tables[1][6 - tomove][to + 8];
                                                             position.second.second ^= zobrist[6 - tomove][to + 8];
                                                             position.first.first[6 - tomove] ^= one_mask[to + 8];
                                                             position.first.first[14 - tomove1] &= ~one_mask[to + 8];}
    else if (position.first.first[6 - tomove] & one_mask[to - 8]){position.second.first[0] -= piece_square_tables[0][6 - tomove][to - 8];
                                                                  position.second.first[1] -= piece_square_tables[1][6 - tomove][to - 8];
                                                                  position.second.second ^= zobrist[6 - tomove][to - 8];
                                                                  position.first.first[6 - tomove] ^= one_mask[to - 8];
                                                                  position.first.first[14 - tomove1] &= ~one_mask[to - 8];}
    capture = true; captured_piece = -1;}
  if (position.first.first[15]){position.second.second ^= zobrist[13][bitScanForward(position.first.first[15])];}
  position.first.first[15] = 0ULL;
  if (captured_piece != -1){position.first.first[captured_piece + 6 - tomove] &= ~one_mask[to];
                            if (captured_piece % 6 != 0) {position.second.first[2] -= material_costs[captured_piece];}
                            position.second.first[0] -= piece_square_tables[0][captured_piece + 6 - tomove][to];
                            position.second.first[1] -= piece_square_tables[1][captured_piece + 6 - tomove][to];
                            position.second.second ^= zobrist[captured_piece + 6 - tomove][to];}
  else if (capture) {for (int i = 6 - tomove; i < 12 - tomove; i++) {if (position.first.first[i] & one_mask[to]){
    if (i % 6 != 0) {position.second.first[2] -= material_costs[i % 6];}
    position.second.first[0] -= piece_square_tables[0][i][to];
    position.second.first[1] -= piece_square_tables[1][i][to];
    position.first.first[i] ^= one_mask[to];
    position.second.second ^= zobrist[i][to]; break;}}}
  else{
    if (move == 20868) {position.first.first[3] ^= 160ULL; position.first.first[13] ^= 160ULL;
    position.second.first[0] += piece_square_tables[0][3][5] - piece_square_tables[0][3][7];
    position.second.first[1] += piece_square_tables[1][3][5] - piece_square_tables[1][3][7];
    position.second.second ^= zobrist[3][7] ^ zobrist[3][5];}
    else if (move == 20612) {position.first.first[3] ^= 9ULL; position.first.first[13] ^= 9ULL;
    position.second.first[0] += piece_square_tables[0][3][3] - piece_square_tables[0][3][0];
    position.second.first[1] += piece_square_tables[1][3][3] - piece_square_tables[1][3][0];
    position.second.second ^= zobrist[3][0] ^ zobrist[3][3];}
    else if (move == 24508) {position.first.first[9] ^= 11529215046068469760ULL; position.first.first[14] ^= 11529215046068469760ULL;
    position.second.first[0] += piece_square_tables[0][9][61] - piece_square_tables[0][9][63];
    position.second.first[1] += piece_square_tables[1][9][61] - piece_square_tables[1][9][63];
    position.second.second ^= zobrist[9][63] ^ zobrist[9][63];}
    else if (move == 24252) {position.first.first[9] ^= 648518346341351424ULL; position.first.first[14] ^= 648518346341351424ULL;
    position.second.first[0] += piece_square_tables[0][9][59] - piece_square_tables[0][9][56];
    position.second.first[1] += piece_square_tables[1][9][59] - piece_square_tables[1][9][56];
    position.second.second ^= zobrist[9][56] ^ zobrist[9][59];}
    else if (piece == tomove and (from - to == -16 or from - to == 16)) {position.first.first[15] = one_mask[(from + to) / 2];
                                                                         position.second.second ^= zobrist[13][(from + to) / 2];}
  }
  if (promotion) {position.first.first[piece] ^= one_mask[to]; position.first.first[promotion] ^= (one_mask[to]);
                 position.second.second ^= zobrist[piece][to] ^ zobrist[promotion][to];
                 position.second.first[0] += piece_square_tables[0][promotion][to] - piece_square_tables[0][piece][to];
                 position.second.first[1] += piece_square_tables[1][promotion][to] - piece_square_tables[1][piece][to];
                 position.second.first[2] += material_costs[promotion % 6];}
  unsigned long long bitboard = position.first.first[12] & 15;
  if (not(position.first.first[5] & one_mask[4])) {position.first.first[12] &= ~12ULL;}
  if (not(position.first.first[11] & one_mask[60])) {position.first.first[12] &= ~3ULL;}
  if (not(position.first.first[3] & one_mask[7])) {position.first.first[12] &= ~8ULL;}
  if (not(position.first.first[3] & one_mask[0])) {position.first.first[12] &= ~4ULL;}
  if (not(position.first.first[9] & one_mask[63])) {position.first.first[12] &= ~2ULL;}
  if (not(position.first.first[9] & one_mask[56])) {position.first.first[12] &= ~1ULL;}
  bitboard ^= position.first.first[12] & 15;
  for (int i = 0; i < 4; i++){if (bitboard & one_mask[i]){position.second.second ^= zobrist[12][i];}}
  if (capture or piece == tomove) {position.first.second.clear(); position.first.first[12] &= 31ULL;}
  else {position.first.first[12] += 32;}

  position.second.second ^= zobrist[12][4];
  position.first.first[12] ^= one_mask[4];
  position.first.second.insert(position.second.second);
  return position;
}



int GetSmallestAttacker(const pair<pair<array<unsigned long long, 16>, multiset<unsigned long long>>, pair<array<int, 3>, unsigned long long>>& position, int square)
{
  int tomove = ((position.first.first[12] >> 4) & 1ULL) * (-6) + 6;
  int ans = 0, move = 0;
  unsigned long long bitboard;
  bitboard  = (left_up_ray[square] | right_up_ray[square]) &
      king_moves[square] & position.first.first[6];
  if (tomove == 6 and bitboard){move = bitScanForward(bitboard) + (square << 6);
                                if (not(Check(MakeMove(position, move), tomove))){return move;}}
  bitboard = (left_down_ray[square] | right_down_ray[square]) &
      king_moves[square] & position.first.first[0];
  if (tomove == 0 and bitboard){move = bitScanForward(bitboard) + (square << 6);
                               if (not(Check(MakeMove(position, move), tomove))){return move;}}
  bitboard = knight_moves[square] & position.first.first[1 + tomove];
  if (bitboard) {move = bitScanForward(bitboard) + (square << 6) + (1 << 12);
                if (not(Check(MakeMove(position, move), tomove))){return move;}}
  unsigned long long pieces = position.first.first[13] | position.first.first[14];
  bitboard = first_one(right_up_ray[square] & pieces);
  if (bitboard & position.first.first[2 + tomove]) {move = bitScanForward(bitboard) + (square << 6) + (2 << 12);
                                             if (not(Check(MakeMove(position, move), tomove))){return move;}}
  if (bitboard & position.first.first[4 + tomove]) {ans = bitScanForward(bitboard) + (square << 6) + (4 << 12);
                                             if (Check(MakeMove(position, ans), tomove)){ans = 0;}}
  bitboard = last_one(right_down_ray[square] & pieces);
  if (bitboard & position.first.first[2 + tomove]) {move = bitScanForward(bitboard) + (square << 6) + (2 << 12);
                                             if (not(Check(MakeMove(position, move), tomove))){return move;}}
  if (bitboard & position.first.first[4 + tomove]) {ans = bitScanForward(bitboard) + (square << 6) + (4 << 12);
                                             if (Check(MakeMove(position, ans), tomove)){ans = 0;}}
  bitboard = first_one(left_up_ray[square] & pieces);
  if (bitboard & position.first.first[2 + tomove]) {move = bitScanForward(bitboard) + (square << 6) + (2 << 12);
                                             if (not(Check(MakeMove(position, move), tomove))){return move;}}
  if (bitboard & position.first.first[4 + tomove]) {ans = bitScanForward(bitboard) + (square << 6) + (4 << 12);
                                             if (Check(MakeMove(position, ans), tomove)){ans = 0;}}
  bitboard = last_one(left_down_ray[square] & pieces);
  if (bitboard & position.first.first[2 + tomove]) {move = bitScanForward(bitboard) + (square << 6) + (2 << 12);
                                             if (not(Check(MakeMove(position, move), tomove))){return move;}}
  if (bitboard & position.first.first[4 + tomove]) {ans = bitScanForward(bitboard) + (square << 6) + (4 << 12);
                                             if (Check(MakeMove(position, ans), tomove)){ans = 0;}}
  bitboard = first_one(right_ray[square] & pieces);
  if (bitboard & position.first.first[3 + tomove]) {move = bitScanForward(bitboard) + (square << 6) + (3 << 12);
                                             if (not(Check(MakeMove(position, move), tomove))){return move;}}
  if (bitboard & position.first.first[4 + tomove]) {ans = bitScanForward(bitboard) + (square << 6) + (4 << 12);
                                             if (Check(MakeMove(position, ans), tomove)){ans = 0;}}
  bitboard = last_one(left_ray[square] & pieces);
  if (bitboard & position.first.first[3 + tomove]) {move = bitScanForward(bitboard) + (square << 6) + (3 << 12);
                                             if (not(Check(MakeMove(position, move), tomove))){return move;}}
  if (bitboard & position.first.first[4 + tomove]) {ans = bitScanForward(bitboard) + (square << 6) + (4 << 12);
                                             if (Check(MakeMove(position, ans), tomove)){ans = 0;}}
  bitboard = first_one(up_ray[square] & pieces);
  if (bitboard & position.first.first[3 + tomove]) {move = bitScanForward(bitboard) + (square << 6) + (3 << 12);
                                             if (not(Check(MakeMove(position, move), tomove))){return move;}}
  if (bitboard & position.first.first[4 + tomove]) {ans = bitScanForward(bitboard) + (square << 6) + (4 << 12);
                                             if (Check(MakeMove(position, ans), tomove)){ans = 0;}}
  bitboard = last_one(down_ray[square] & pieces);
  if (bitboard & position.first.first[3 + tomove]) {move = bitScanForward(bitboard) + (square << 6) + (3 << 12);
                                             if (not(Check(MakeMove(position, move), tomove))){return move;}}
  if (bitboard & position.first.first[4 + tomove]) {ans = bitScanForward(bitboard) + (square << 6) + (4 << 12);
                                             if (Check(MakeMove(position, ans), tomove)){ans = 0;}}
  if (ans != 0) {return ans;}
  bitboard = king_moves[square] & position.first.first[5 + tomove];
  if (bitboard) {move = bitScanForward(bitboard) + (square << 6) + (5 << 12);
                if (not(Check(MakeMove(position, move), tomove))){return move;}}
  return 0;
}



vector<int> LegalMoves(pair<pair<array<unsigned long long, 16>, multiset<unsigned long long>>, pair<array<int, 3>, unsigned long long>> position, int tomove_ = 0) {
  int tomove = ((position.first.first[12] >> 4) & 1ULL) * (-6) + 6;
  if (tomove_ == 1) {position.first.first[12] |= one_mask[4]; tomove = 0;}
  else if (tomove_ == -1) {position.first.first[12] &= ~one_mask[4]; tomove = 6;}
  int from, to, move;
  vector<int> legal_moves;
  unsigned long long bitboard, moves;
  bitboard = position.first.first[tomove];
  while (bitboard) {
    from = bitScanForward(bitboard);
    moves = PawnMoves(position, from);
    while (moves){
      to = bitScanForward(moves);
      if (to >= 56 or to < 8) {
        if (Check(MakeMove(position, from + (to << 6)), tomove)) {moves ^= one_mask[to]; continue;}
        for (int permotion = 1; permotion <= 4; permotion++) {
          move = from + (to << 6) + (permotion << 15);
          legal_moves.push_back(move);
        }
        moves ^= one_mask[to];
        continue;
      }
      move = from + (to << 6);
      if (Check(MakeMove(position, move), tomove)) {moves ^= one_mask[to]; continue;}
      legal_moves.push_back(move);
      moves ^= one_mask[to];
    }
    bitboard ^= one_mask[from];
  }
  bitboard = position.first.first[1 + tomove];
  while (bitboard) {
    from = bitScanForward(bitboard);
    moves = KnightMoves(position, from);
    while (moves){
      to = bitScanForward(moves);
      move = from + (to << 6) + (1 << 12);
      if (Check(MakeMove(position, move), tomove)) {moves ^= one_mask[to]; continue;}
      legal_moves.push_back(move);
      moves ^= one_mask[to];
    }
    bitboard ^= one_mask[from];
  }
  bitboard = position.first.first[2 + tomove];
  while (bitboard) {
    from = bitScanForward(bitboard);
    moves = BishopMoves(position, from);
    while (moves){
      to = bitScanForward(moves);
      move = from + (to << 6) + (2 << 12);
      if (Check(MakeMove(position, move), tomove)) {moves ^= one_mask[to]; continue;}
      legal_moves.push_back(move);
      moves ^= one_mask[to];
    }
    bitboard ^= one_mask[from];
  }
  bitboard = position.first.first[3 + tomove];
  while (bitboard) {
    from = bitScanForward(bitboard);
    moves = RookMoves(position, from);
    while (moves){
      to = bitScanForward(moves);
      move = from + (to << 6) + (3 << 12);
      if (Check(MakeMove(position, move), tomove)) {moves ^= one_mask[to]; continue;}
      legal_moves.push_back(move);
      moves ^= one_mask[to];
    }
    bitboard ^= one_mask[from];
  }
  bitboard = position.first.first[4 + tomove];
  while (bitboard) {
    from = bitScanForward(bitboard);
    moves = QueenMoves(position, from);
    while (moves){
      to = bitScanForward(moves);
      move = from + (to << 6) + (4 << 12);
      if (Check(MakeMove(position, move), tomove)) {moves ^= one_mask[to]; continue;}
      legal_moves.push_back(move);
      moves ^= one_mask[to];
    }
    bitboard ^= one_mask[from];
  }
  bitboard = position.first.first[5 + tomove];
  while (bitboard) {
    from = bitScanForward(bitboard);
    moves = KingMoves(position, from);
    while (moves){
      to = bitScanForward(moves);
      move = from + (to << 6) + (5 << 12);
      if (Check(MakeMove(position, move), tomove)) {moves ^= one_mask[to]; continue;}
      legal_moves.push_back(move);
      moves ^= one_mask[to];
    }
    bitboard ^= one_mask[from];
  }

  return legal_moves;
}



bool Mate(const pair<pair<array<unsigned long long, 16>, multiset<unsigned long long>>, pair<array<int, 3>, unsigned long long>>& position){
  int tomove = ((position.first.first[12] >> 4) & 1ULL) * (-6) + 6;
  int from, to, move;
  unsigned long long bitboard, moves;
  bitboard = position.first.first[tomove];
  while (bitboard) {
    from = bitScanForward(bitboard);
    moves = PawnMoves(position, from);
    while (moves){
      to = bitScanForward(moves);
      if (to >= 56 or to < 8) {
        if (Check(MakeMove(position, from + (to << 6)), tomove)) {moves ^= one_mask[to]; continue;}
        return false;
      }
      move = from + (to << 6);
      if (Check(MakeMove(position, move), tomove)) {moves ^= one_mask[to]; continue;}
      return false;
      moves ^= one_mask[to];
    }
    bitboard ^= one_mask[from];
  }
  bitboard = position.first.first[1 + tomove];
  while (bitboard) {
    from = bitScanForward(bitboard);
    moves = KnightMoves(position, from);
    while (moves){
      to = bitScanForward(moves);
      move = from + (to << 6) + (1 << 12);
      if (Check(MakeMove(position, move), tomove)) {moves ^= one_mask[to]; continue;}
      return false;
    }
    bitboard ^= one_mask[from];
  }
  bitboard = position.first.first[2 + tomove];
  while (bitboard) {
    from = bitScanForward(bitboard);
    moves = BishopMoves(position, from);
    while (moves){
      to = bitScanForward(moves);
      move = from + (to << 6) + (2 << 12);
      if (Check(MakeMove(position, move), tomove)) {moves ^= one_mask[to]; continue;}
      return false;
    }
    bitboard ^= one_mask[from];
  }
  bitboard = position.first.first[3 + tomove];
  while (bitboard) {
    from = bitScanForward(bitboard);
    moves = RookMoves(position, from);
    while (moves){
      to = bitScanForward(moves);
      move = from + (to << 6) + (3 << 12);
      if (Check(MakeMove(position, move), tomove)) {moves ^= one_mask[to]; continue;}
      return false;
    }
    bitboard ^= one_mask[from];
  }
  bitboard = position.first.first[4 + tomove];
  while (bitboard) {
    from = bitScanForward(bitboard);
    moves = QueenMoves(position, from);
    while (moves){
      to = bitScanForward(moves);
      move = from + (to << 6) + (4 << 12);
      if (Check(MakeMove(position, move), tomove)) {moves ^= one_mask[to]; continue;}
      return false;
    }
    bitboard ^= one_mask[from];
  }
  bitboard = position.first.first[5 + tomove];
  while (bitboard) {
    from = bitScanForward(bitboard);
    moves = KingMoves(position, from);
    while (moves){
      to = bitScanForward(moves);
      move = from + (to << 6) + (5 << 12);
      if (Check(MakeMove(position, move), tomove)) {moves ^= one_mask[to]; continue;}
      return false;
    }
    bitboard ^= one_mask[from];
  }

  return true;
}


bool notEnoughtPiece(const pair<pair<array<unsigned long long, 16>, multiset<unsigned long long>>, pair<array<int, 3>, unsigned long long>>& position){
  if (position.first.first[0] | position.first.first[6]){
    return false;
  }
  if (position.first.first[3] | position.first.first[9]){
    return false;
  }
  if (position.first.first[4] | position.first.first[10]){
    return false;
  }
  int pop = Population(position.first.first[13] | position.first.first[14]);
  if (pop <= 3){
    return true;
  }
  if (pop >= 5) {
    return false;
  }
  if ((position.first.first[2] | position.first.first[8]) == 0){
    if (position.first.first[1] * position.first.first[7]){
      return false;
    }
    else{
      return false;
    }
  }
  if ((position.first.first[1] | position.first.first[7]) == 0){
    if ((position.first.first[2] & WHITE_SQUARES) xor (position.first.first[8] & WHITE_SQUARES) ){
      return false;
    }
    else{
      return true;
    }
  }
  return false;
}


vector<int> LegalTakes(pair<pair<array<unsigned long long, 16>, multiset<unsigned long long>>, pair<array<int, 3>, unsigned long long>> position, int tomove_ = 0) {
  int tomove = ((position.first.first[12] >> 4) & 1ULL) * (-6) + 6;
  if (tomove_ == 1) {position.first.first[12] |= one_mask[4]; tomove = 0;}
  else if (tomove_ == -1) {position.first.first[12] &= ~one_mask[4]; tomove = 6;}
  int from, to, take;
  vector<int> legal_takes;
  unsigned long long bitboard, takes;
  bitboard = position.first.first[tomove];
  while (bitboard) {
    from = bitScanForward(bitboard);
    takes = PawnTakes(position, from);
    while (takes){
      to = bitScanForward(takes);
      if (to >= 56 or to < 8) {
        if (Check(MakeMove(position, from + (to << 6)), tomove)) {takes ^= one_mask[to]; continue;}
        for (int promotion = 1; promotion <= 4; promotion++) {
          take = from + (to << 6) + (promotion << 15);
          legal_takes.push_back(take);
        }
        takes ^= one_mask[to];
        continue;
      }
      take = from + (to << 6);
      if (Check(MakeMove(position, take), tomove)) {takes ^= one_mask[to]; continue;}
      legal_takes.push_back(take);
      takes ^= one_mask[to];
    }
    bitboard ^= one_mask[from];
  }
  bitboard = position.first.first[1 + tomove];
  while (bitboard) {
    from = bitScanForward(bitboard);
    takes = KnightTakes(position, from);
    while (takes){
      to = bitScanForward(takes);
      take = from + (to << 6) + (1 << 12);
      if (Check(MakeMove(position, take), tomove)) {takes ^= one_mask[to]; continue;}
      legal_takes.push_back(take);
      takes ^= one_mask[to];
    }
    bitboard ^= one_mask[from];
  }
  bitboard = position.first.first[2 + tomove];
  while (bitboard) {
    from = bitScanForward(bitboard);
    takes = BishopTakes(position, from);
    while (takes){
      to = bitScanForward(takes);
      take = from + (to << 6) + (2 << 12);
      if (Check(MakeMove(position, take), tomove)) {takes ^= one_mask[to]; continue;}
      legal_takes.push_back(take);
      takes ^= one_mask[to];
    }
    bitboard ^= one_mask[from];
  }
  bitboard = position.first.first[3 + tomove];
  while (bitboard) {
    from = bitScanForward(bitboard);
    takes = RookTakes(position, from);
    while (takes){
      to = bitScanForward(takes);
      take = from + (to << 6) + (3 << 12);
      if (Check(MakeMove(position, take), tomove)) {takes ^= one_mask[to]; continue;}
      legal_takes.push_back(take);
      takes ^= one_mask[to];
    }
    bitboard ^= one_mask[from];
  }
  bitboard = position.first.first[4 + tomove];
  while (bitboard) {
    from = bitScanForward(bitboard);
    takes = QueenTakes(position, from);
    while (takes){
      to = bitScanForward(takes);
      take = from + (to << 6) + (4 << 12);
      if (Check(MakeMove(position, take), tomove)) {takes ^= one_mask[to]; continue;}
      legal_takes.push_back(take);
      takes ^= one_mask[to];
    }
    bitboard ^= one_mask[from];
  }
  bitboard = position.first.first[5 + tomove];
  while (bitboard) {
    from = bitScanForward(bitboard);
    takes = KingTakes(position, from);
    while (takes){
      to = bitScanForward(takes);
      take = from + (to << 6) + (5 << 12);
      if (Check(MakeMove(position, take), tomove)) {takes ^= one_mask[to]; continue;}
      legal_takes.push_back(take);
      takes ^= one_mask[to];
    }
    bitboard ^= one_mask[from];
  }

  return legal_takes;
}



int input_move(pair<pair<array<unsigned long long, 16>, multiset<unsigned long long>>, pair<array<int, 3>, unsigned long long>> position){
  char mv1, mv2, mv3, mv4, mv5;
  cin >> mv1 >> mv2 >> mv3 >> mv4;
  int move = (mv1 - 'a') + (mv2 - '1') * 8 + (mv3 - 'a') * 64 + (mv4 - '1') * 64 * 8;
  if (move == 0){
    history.pop();
    history.pop();
    return input_move(history.top());
  }
  int piece = 0;
  for (int i = 0; i < 12; i++){
    if (one_mask[move & 63] & position.first.first[i]) {move |= (i % 6) << 12; piece = i % 6; break;}
  }
  if (piece == 0 and (mv4 == '8' or mv4 == '1')){
    cin >> mv5;
    if (mv5 == 'n') {move |= (1 << 15);}
    if (mv5 == 'b') {move |= (2 << 15);}
    if (mv5 == 'r') {move |= (3 << 15);}
    if (mv5 == 'q') {move |= (4 << 15);}
  }
  vector<int> legal_moves = LegalMoves(position);
  if (find(legal_moves.begin(), legal_moves.end(), move) == legal_moves.end()){
    cout << "Illegal move" << endl;
    return input_move(position);
  }
  return move;
}


double phase_solver(const pair<pair<array<unsigned long long, 16>, multiset<unsigned long long>>, pair<array<int, 3>, unsigned long long>>& position){
    double a = 10;
    double phase = (double)position.second.first[2] / (double)6400;
    phase = 1.0 / (1.0 + exp(-a * (phase - 0.5)));
    return phase;
}


const array<int, 100> SafetyTable = {
   0,   0,   1,   2,   3,   5,   7,   9,  12,  15,
  18,  22,  26,  30,  35,  39,  44,  50,  56,  62,
  68,  75,  82,  85,  89,  97, 105, 113, 122, 131,
 140, 150, 169, 180, 191, 202, 213, 225, 237, 248,
 260, 272, 283, 295, 307, 319, 330, 342, 354, 366,
 377, 389, 401, 412, 424, 436, 448, 459, 471, 483,
 494, 500, 500, 500, 500, 500, 500, 500, 500, 500,
 500, 500, 500, 500, 500, 500, 500, 500, 500, 500,
 500, 500, 500, 500, 500, 500, 500, 500, 500, 500,
 500, 500, 500, 500, 500, 500, 500, 500, 500, 500};


const array<int, 9> DubledTableOppening = {  0,   0,  27,  90, 162, 243, 333, 432, 531};
const array<int, 9> DubledTableEndgame  = {  0,   0,  34, 130, 234, 351, 481, 624, 767};
const array<int, 8> PassingTable = {0, 10, 30, 40, 70, 90, 105, 0};
const array<array<int, 9>, 2> DubledTable = {DubledTableOppening, DubledTableEndgame};

int Evaluation(const pair<pair<array<unsigned long long, 16>, multiset<unsigned long long>>, pair<array<int, 3>, unsigned long long>>& position){
  if (notEnoughtPiece(position)){return 0;}
  double phase = phase_solver(position);
  int evaluation = position.second.first[0] * phase + position.second.first[1] * (1.0 - phase);
  //cout << ' ' << position.second.first[0] << ' ' << position.second.first[1] << ' ' << phase << ' ' << evaluation << endl;
  for (int i = 0; i < 8; i++){
    int dubled_white = Population(position.first.first[0] & (up_ray[i] | one_mask[i]));
    int dubled_black = Population(position.first.first[6] & (up_ray[i] | one_mask[i]));
    if (dubled_white == 1 and ((i == 0 or not(position.first.first[0] & up_ray[i - 1])) and
      (i == 7 or not(position.first.first[0] & up_ray[i + 1])))) {evaluation -= 10.0 * phase + 50.0 * (1.0 - phase);}
    else if (dubled_white >= 2) {evaluation -= DubledTable[0][dubled_white] * phase + DubledTable[1][dubled_white] * (1.0 - phase);}
    if (dubled_black == 1 and ((i == 0 or not(position.first.first[6] & up_ray[i - 1])) and
    (i == 7 or not(position.first.first[6] & up_ray[i + 1])))) {10 * phase + 50.0 * (1.0 - phase);}
    else if (dubled_black >= 2) {evaluation += DubledTable[0][dubled_black] * phase + DubledTable[1][dubled_black] * (1.0 - phase);}
  }
  unsigned long long bitboard = position.first.first[0];
  while (bitboard){
    int square = bitScanForward(bitboard);
    if (not(passing_mask_white[square] & position.first.first[6])){
        evaluation += PassingTable[square / 8];}
    bitboard ^= first_one(bitboard);
  }
  bitboard = position.first.first[6];
  while (bitboard){
    int square = bitScanForward(bitboard);
    if (not(passing_mask_black[square] & position.first.first[0])){
        evaluation -= PassingTable[7 - square / 8];}
    bitboard ^= first_one(bitboard);
  }
  bitboard = position.first.first[3];
  int square;
  while (bitboard) {
    square = bitScanForward(bitboard);
    if (not(position.first.first[0] & (up_ray[square] | down_ray[square]))) {
      if (not(position.first.first[6] & (up_ray[square] | down_ray[square]))) {evaluation += 30;} else {evaluation += 20;}
    }
    bitboard ^= one_mask[square];
  }
  bitboard = position.first.first[9];
  while (bitboard) {
    square = bitScanForward(bitboard);
    if (not(position.first.first[6] & (up_ray[square] | down_ray[square]))) {
      if (not(position.first.first[0] & (up_ray[square] | down_ray[square]))) {evaluation -= 30;} else {evaluation -= 20;}
    }
    bitboard ^= one_mask[square];
  }

  int safety_index = 0, from;
  int king_position = bitScanForward(position.first.first[11]);
  bitboard = position.first.first[1];
  while (bitboard) {
    from = bitScanForward(bitboard);
    safety_index += Population(KnightAttacks(position, from) & black_king_zone[king_position]) * 2;
    bitboard ^= one_mask[from];
  }
  bitboard = position.first.first[2];
  while (bitboard) {
    from = bitScanForward(bitboard);
    safety_index += Population(BishopAttacks(position, from) & black_king_zone[king_position]) * 2;
    bitboard ^= one_mask[from];
  }
  bitboard = position.first.first[3];
  while (bitboard) {
    from = bitScanForward(bitboard);
    safety_index += Population(RookAttacks(position, from) & black_king_zone[king_position]) * 3;
    bitboard ^= one_mask[from];
  }
  bitboard = position.first.first[4];
  while (bitboard) {
    from = bitScanForward(bitboard);
    safety_index += Population(QueenAttacks(position, from) & black_king_zone[king_position]) * 5;
    bitboard ^= one_mask[from];
  }
  if (QueenAttacks(position, king_position) & position.first.first[4]){safety_index += 6;}
  if (RookAttacks(position, king_position) & position.first.first[3]){safety_index += 2;}
  evaluation += SafetyTable[safety_index];

  safety_index = 0;
  king_position = bitScanForward(position.first.first[5]);
  bitboard = position.first.first[7];
  while (bitboard) {
    from = bitScanForward(bitboard);
    safety_index += Population(KnightAttacks(position, from) & white_king_zone[king_position]) * 2;
    bitboard ^= one_mask[from];
  }
  bitboard = position.first.first[8];
  while (bitboard) {
    from = bitScanForward(bitboard);
    safety_index += Population(BishopAttacks(position, from) & white_king_zone[king_position]) * 2;
    bitboard ^= one_mask[from];
  }
  bitboard = position.first.first[9];
  while (bitboard) {
    from = bitScanForward(bitboard);
    safety_index += Population(RookAttacks(position, from) & white_king_zone[king_position]) * 3;
    bitboard ^= one_mask[from];
  }
  bitboard = position.first.first[10];
  while (bitboard) {
    from = bitScanForward(bitboard);
    safety_index += Population(QueenAttacks(position, from) & white_king_zone[king_position]) * 5;
    bitboard ^= one_mask[from];
  }
  if (QueenAttacks(position, king_position) & position.first.first[10]){safety_index += 6;}
  if (RookAttacks(position, king_position) & position.first.first[9]){safety_index += 2;}
  evaluation -= SafetyTable[safety_index];
  return evaluation;
}


int maxx(int a, int b){
    if (a > b) {return a;}
    return b;
}


int SEE(const pair<pair<array<unsigned long long, 16>, multiset<unsigned long long>>, pair<array<int, 3>, unsigned long long>>& position, int square, int piece, int depth)
{
  DEPTH = maxx(DEPTH, depth);
  int move = GetSmallestAttacker(position, square);
  if (move == 0) {return 0;}
  return maxx(0, material_costs[piece]
    - SEE(MakeMove(position, move, piece), square, (move >> 12) & 7, depth + 1));
}


int QuiescenceSearch(const pair<pair<array<unsigned long long, 16>, multiset<unsigned long long>>, pair<array<int, 3>, unsigned long long>>& position, int depth, int alpha = INF + 1){
  int my_best_move = 0;
  DEPTH = maxx(DEPTH, depth);
  unsigned long long hash_of_position = position.second.second;
  if (hash_table.count(hash_of_position)) {return (hash_table[hash_of_position] & ((1 << 24) - 1)) - (1 << 23);}
  int tomove = ((position.first.first[12] >> 4) & 1ULL) * 2 - 1;
  if (alpha == INF + 1) {alpha = 3 * INF * tomove;}
  vector<int> takes = LegalTakes(position);
  if (takes.size() == 0) {return Evaluation(position);}
  int rate, captured_piece;
  rate = Evaluation(position);
  pair<pair<array<unsigned long long, 16>, multiset<unsigned long long>>, pair<array<int, 3>, unsigned long long>> position_now;
  for (auto take: takes) {
    captured_piece = -1;
    for (int i = 3 + tomove * 3; i < 9 + tomove * 3; i++){
      if (position.first.first[i] & one_mask[(take >> 6) & 63]) {captured_piece = i % 6; break;}}
    position_now = MakeMove(position, take, captured_piece);
    if (captured_piece == -1) {captured_piece = 0;}
    if (((take >> 6) & 63ULL) / 8 != (4 + 4 * tomove)){
      if ((Evaluation(position_now) + 200 * tomove - rate) * tomove < 0){continue;}
      if ((material_costs[captured_piece] - SEE(position_now, (take >> 6) & 63, (take >> 12) & 7, depth) <= 0)){continue;}
    }
    int rate_now = QuiescenceSearch(position_now, depth + 1, rate);
    if ((rate - rate_now) * tomove < 0) {rate = rate_now; my_best_move = take;}
    if ((rate - alpha) * tomove >= 0) {return INF * 3 * tomove;}
    if ((double)(clock() - start) / CLOCKS_PER_SEC > time_for_move_out) {
    hash_table[hash_of_position] = rate + (1 << 23); return rate;}
  }
  hash_table[hash_of_position] = rate + (1 << 23);
  return rate;
}


int Rate(const pair<pair<array<unsigned long long, 16>, multiset<unsigned long long>>, pair<array<int, 3>, unsigned long long>>& position, int recursion, int depth, int alpha, int premove = -1, bool root = false) // rate position and choose best move
{
  int my_best_move = 0;
  DEPTH = maxx(DEPTH, depth);
  int rate, final_rate, move, extension, rec = 1;
  unsigned long long hash_of_position = position.second.second;
  if (position.first.second.count(hash_of_position) >= 3 or (position.first.first[12] >> 5) >= 100) {return 0;}
  if (hash_table.count(hash_of_position)){if ((hash_table[hash_of_position] >> 24) >= recursion + 1)
    {return (hash_table[hash_of_position] & ((1 << 24) - 1)) - (1 << 23);} else {rec = maxx((hash_table[hash_of_position] >> 24) - 1, rec);}}
  int tomove = ((position.first.first[12] >> 4) & 1ULL) * 2 - 1;
  if (alpha == INF + 1) {alpha = 3 * INF * tomove;}
  if (Mate(position)){if (Check(position)) {rate = -INF * tomove;} else {rate = 0;}
  hash_table[hash_of_position] = (64 << 24) + rate + (1 << 23); return rate;}
  if (notEnoughtPiece(position)){rate = 0; hash_table[hash_of_position] = (64 << 24) + rate + (1 << 23); return rate;}
  if (recursion <= 0 and not(Check(position))) {int rate = QuiescenceSearch(position, depth);
  hash_table[hash_of_position] = ((recursion + 1) << 24) + rate + (1 << 23); return rate;}
  vector<pair<int, int>> moves;
  vector<int> legal_moves = LegalMoves(position);
  for (int move: legal_moves) {moves.push_back(make_pair(-history_evr[(tomove + 1) / 2][move & 63][(move >> 6) & 63] -
                                        (counterMove[premove & 63][(premove >> 6) & 63] == move ? 100 : 0), move));}
  if (moves.size() == 1 and not(root)){
    int rate = Rate(MakeMove(position, moves[0].second), recursion, depth + 1, -INF * tomove);
    if (rate >= INF / 2) {rate--;}
    if (rate <= -INF / 2) {rate++;}
    if ((rate - alpha) * tomove >= 0) {return INF * 3 * tomove;}
  hash_table[hash_of_position] = rate + (1 << 23) + ((recursion + 1) << 24);
    if (root) {best_move = moves[0].second;}
    return rate;
  }
  if (not(root)){rec = recursion;}
  for (; rec <= recursion or rec == 1; rec += 1){
    if (root){depth_dictated = rec;}
    rate = -INF * 3 * tomove;
    sort(moves.begin(), moves.end());
    for (int i = 0; i < moves.size(); i++) {
      move = moves[i].second;
      extension = 0;
      pair<pair<array<unsigned long long, 16>, multiset<unsigned long long>>, pair<array<int, 3>, unsigned long long>> position_now = MakeMove(position, move);
      if ((rec == 1 and not(Check(position_now) and not(position.first.first[13.5 + 0.5 * tomove] & one_mask[(move >> 6) & 63])))
           and (Evaluation(position_now) + 100 * tomove - rate) * tomove < 0){moves[i].first = INF; continue;}
      if (((move >> 12) & 7) == 0) {
        if ((tomove == 1 and ((move >> 6) & 63) / 8 == 6) or
          (tomove == -1 and ((move >> 6) & 63) / 8 == 1)) {extension = 1;}
      }
      int rate_now = Rate(position_now, rec - 1 + extension, depth + 1, rate == -INF * 3 * tomove ? -(INF / 2) * tomove : rate, move);
      if (rate_now >= INF / 2) {rate_now--;}
      if (rate_now <= -INF / 2) {rate_now++;}
      //if (root) {cout << rec << ' '; print_move(move); cout << rate_now << endl;}
      if ((double)(clock() - start) / CLOCKS_PER_SEC > time_for_move_out) {if (rate == -INF * 3 * tomove){rate = final_rate;}
        hash_table[hash_of_position] = rate + (1 << 23) + ((recursion + 1) << 24); return rate;}
      if ((rate - rate_now) * tomove < 0) {rate = rate_now; my_best_move = move; if (root) {best_move = move;}}
      moves[i].first = -rate_now * tomove - (history_evr[(tomove + 1) / 2][move & 63][(move >> 6) & 63] +
      (counterMove[premove & 63][(premove >> 6) & 63] == move ? 100 : 0)) / 15;
      if (rec == recursion and (rate - alpha) * tomove > 0) {
        if (not(position.first.first[13.5 + 0.5 * tomove] & one_mask[(move >> 6) & 63])){
          history_evr[(tomove + 1) / 2][move & 63][(move >> 6) & 63] += recursion * recursion;
          counterMove[premove & 63][(premove >> 6) & 63] = move;} return rate;}
      if (root and (double)(clock() - start) / CLOCKS_PER_SEC > time_for_move) {
        hash_table[hash_of_position] = rate + (1 << 23) + ((recursion + 1) << 24); return rate;}
      if (root and printing and (double)(clock() - start) / CLOCKS_PER_SEC > 0.1 * 0){
        cout << rate << ' ' << best_move << endl;// ' ';cout << ' ' << rec << ' '; print_move(best_move); cout << endl;
      }
    }
    //if (not(root) and (rate >= INF / 2 or rate <= -INF / 2)) {return rate;}
    if (root and printing and (rate >= INF / 2 or rate <= -INF / 2)){return rate;}
    final_rate = rate;
    //if(root) {hash_table[hash_of_position] = rate + (1 << 23) + ((rec + 1) << 24);}
  }
  hash_table[hash_of_position] = rate + (1 << 23) + ((recursion + 1) << 24);
  return rate;
}

int RateThePosition(const pair<pair<array<unsigned long long, 16>, multiset<unsigned long long>>, pair<array<int, 3>, unsigned long long>>& position, int recursion = 64){
  hash_table.clear();
  for (int i = 0; i < 2; i++) {for (int j = 0; j < 64; j++) {fill(history_evr[i][j].begin(), history_evr[i][j].end(), 0);}}
  for (int j = 0; j < 64; j++) {fill(counterMove[j].begin(), counterMove[j].end(), -1);}
  start = clock();
  return Rate(position, recursion, 0, INF + 1, -1, true);
}


void print_first_line(pair<pair<array<unsigned long long, 16>, multiset<unsigned long long>>, pair<array<int, 3>, unsigned long long>> position){
  auto hash_of_position = position.second.second;
  int tomove = ((position.first.first[12] >> 4) & 1ULL) * 2 - 1;
  if (position.first.second.count(hash_of_position) >= 3){cout << "=="; return;}
  if ((position.first.first[12] >> 5) >= 100) {cout << "\""; return;}
  if (Mate(position)){if(Check(position)){cout << "#";} else{cout << "#=";} return;}
  pair<int, int> my_best_move = {-INF * tomove + (1 << 23), 0};
  for (auto move: LegalMoves(position)){
    auto new_hash = MakeMove(position, move).second.second;
    if (hash_table.count(new_hash) and ((hash_table[new_hash] & ((1 << 24) - 1)) - my_best_move.first) * tomove >= 0){
        my_best_move = {hash_table[new_hash], move};
    }
  }

if (my_best_move.second == 0) {return;}
print_move(my_best_move.second);
cout << "/ ";
print_first_line(MakeMove(position, my_best_move.second));
}


void time_tester(long long N){
  auto start_test = clock();
  for (int i = 0; i < N; i++){
    RateThePosition(position_start, 5);
  }
  auto end_test = clock();
  cout << "time: " << (double)(end_test - start_test) / CLOCKS_PER_SEC << endl;
}


//FEN: rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - 0 0
int main(){
  hash_table.max_load_factor(0.25);
  string FEN;
  getline(cin, FEN);
  string mode;
  cin >> mode;
  if (mode == "lm"){
    vector<int> legals = LegalMoves(position_recount(FEN_to_bitboards(FEN)));
    for (auto move: legals){
      cout << move << endl; //print_move(move); cout << endl;
    }
  }
  else if (mode == "ck"){
    cout << (Check(position_recount(FEN_to_bitboards(FEN) )) ? 1 : 0) << endl;
  }
  else if (mode == "go"){
    string s;
    cin >> s;
    int d;
    if (s == "time"){
      double t1, t2;
      cin >> t1 >> t2;
      time_for_move = t1;
      time_for_move_out = t2;
      d = 30;
      printing = false;
    }
    else if (s == "depth"){
      cin >> d;
      time_for_move = 120;
      time_for_move_out = 180;
      printing = false;
    }
    else if (s == "infinity"){
      time_for_move = 600000;
      time_for_move_out = 700000;
      d = 60;
      printing = true;
    }
    pair<pair<array<unsigned long long, 16>, multiset<unsigned long long>>, pair<array<int, 3>, unsigned long long>> position;
    position = position_recount(FEN_to_bitboards(FEN));
    position.first.second.insert(position.second.second);
    while(true){
      int h;
      cin >> h;
      if (h == -1){break;}
      position = MakeMove(position, h);
      //print_move(h);
      //print_position(position);
    }

    vector<int> legals = LegalMoves(position);

    int rate = RateThePosition(position, d);
    //if (s == "time") {while ((double)(clock() - start) / CLOCKS_PER_SEC < time_for_move){}}
    cout << rate << ' ' << best_move << endl;// << ' ' << int((double)(clock() - start) / CLOCKS_PER_SEC * 1000) << endl;
  }
  return 0;
}
